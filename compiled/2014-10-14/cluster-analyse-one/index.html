<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Cluster机制剖析1——进程复制</title>
  
    <meta name="author" content="Ruoqi Deng">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/twitter/stylesheets/bootstrap.min.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/twitter/stylesheets/style.css" type="text/css" rel="stylesheet" media="all">
<link href="/assets/twitter/widgets/google_prettify/stylesheets/twitter-bootstrap.css" type="text/css" rel="stylesheet" media="all">
 

    <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
  </head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">Lucky Blog</a>
          <ul class="nav">
            
              


  <li><a href="/archive">Archive</a></li>


            
              


  <li><a href="/tags">Tags</a></li>


            
              


  <li><a href="/categories">Categories</a></li>


            
              


  <li><a href="/pages">Pages</a></li>


            
              


  <li><a href="/about">About Me</a></li>


            
          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        <div class="page-header">
  <h1>Cluster机制剖析1——进程复制 </h1>
</div>

<div class="row">
  <div class="span8">
    <p>Cluster相信大家都很熟悉，这里就不再赘述了，引用官网的一段话：</p>

<blockquote>
<p>A single instance of Node runs in a single thread. To take advantage of multi-core systems the user will sometimes want to launch a cluster of Node processes to handle the load.</p>
</blockquote>

<p>本文将基于<code>node_v0.10.32</code>来八一八它的实现原理。</p>

<h3>Fork</h3>

<p><a href="http://en.wikipedia.org/wiki/Fork_(system_call">fork()</a>是类UNIX系统父进程复制子进程的系统调用，在Node里通过<a href="https://github.com/joyent/libuv">libuv</a>实现了对不同平台(unix,linux,windows)的封装。引用<a href="http://baike.baidu.com/view/1952900.htm">百度百科</a>的一段话来描述<code>fork</code>的特性：</p>

<blockquote>
<p>fork之后的子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。</p>
</blockquote>

<p>其实，在node的<code>cluster</code>模式里，worker进程的产生也是调用了<code>require('child_process').fork</code>。</p>

<p><strong>那直接这样不就行了？</strong></p>

<pre><code>var fork = require('child_process').fork;
var cpuNums = require('os').cpus().length;
var workerPath = require('path').join(__dirname, 'worker.js'); 

for (var i = 0; i &lt; cpuNums; i++) {
  fork(workerPath, { env: process.env });
}
</code></pre>

<p>这样的方式仅仅实现了多进程。多进程运行还涉及<strong>父子进程通信，子进程管理，以及负载均衡</strong>等问题，这些特性<code>cluster</code>帮你实现了，在后面的章节会一一道来。</p>

<h3>两种逻辑</h3>

<p>先看一个官网的例子：</p>

<pre><code>var cluster = require('cluster');
var http = require('http');
var numCPUs = require('os').cpus().length;

if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', function(worker, code, signal) {
    console.log('worker ' + worker.process.pid + ' died');
  });
} else {
  // Workers can share any TCP connection
  // In this case its a HTTP server
  http.createServer(function(req, res) {
    res.writeHead(200);
    res.end(&quot;hello world\n&quot;);
  }).listen(8000);
}
</code></pre>

<p>以上代码的意思是：如果是父进程（Master），就复制多个子进程，子进程的数目等于CPU核心数。如果是子进程（Worker），就创建一个http服务器并监听8000端口。</p>

<p>我们在前面提到，子进程是父进程的“副本”，将得到父进程的数据（代码）空间及堆栈，因此，父子进程会执行<strong>同一段代码逻辑</strong>。这样就需要一种机制，能够在代码里区分当前进程是父进程还是子进程。首先来看看神秘的<code>cluster</code>模块究竟是什么：</p>

<pre><code>// lib/cluster.js

function Cluster() {
  EventEmitter.call(this);
}

util.inherits(Cluster, EventEmitter);

var cluster = module.exports = new Cluster();
</code></pre>

<p>它是一个<code>Object</code>，通过继承<code>EventEmitter</code>，使它有了事件驱动机制。</p>

<pre><code>// Define isWorker and isMaster
cluster.isWorker = 'NODE_UNIQUE_ID' in process.env;
cluster.isMaster = ! cluster.isWorker;
</code></pre>

<p>可以看到<code>cluster</code>下有两个flag来标识区分当前进程，依据是当前进程的环境变量（<code>env</code>）里是否包含<code>NODE_UNIQUE_ID</code>这个字段。<strong>为什么子进程的环境变量里有这个字段而父进程没有？</strong></p>

<p>我们知道，在复制子进程的时候实际上是调用了<code>require('child_process').fork</code>，看一下这个方法的用法：</p>

<pre><code>child_process.fork(modulePath, [args], [options])
  modulePath String The module to run in the child
  args Array List of string arguments
  options Object
    cwd String Current working directory of the child process
    env Object Environment key-value pairs
    encoding String (Default: 'utf8')
    execPath String Executable used to create the child process
    execArgv Array List of string arguments passed to the executable (Default: process.execArgv)
    silent Boolean If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the &quot;pipe&quot; and &quot;inherit&quot; options for spawn()'s stdio for more details (default is false)
  Return: ChildProcess object
</code></pre>

<p>可以看到方法的第三个参数<code>options</code>是个对象，其中<code>options.env</code>可以设置子进程的环境变量，即<code>process.env</code>。因此，可以推测，应该是这里调用的时候，在env里面添加了<code>NODE_UNIQUE_ID</code>这个标识。接下来就来看下代码：</p>

<pre><code>function Worker(customEnv) {
  ...
  // Create or get process
  if (cluster.isMaster) {

    // Create env object
    // first: copy and add id property
    var envCopy = util._extend({}, env);
    envCopy['NODE_UNIQUE_ID'] = this.id;
    // second: extend envCopy with the env argument
    if (isObject(customEnv)) {
      envCopy = util._extend(envCopy, customEnv);
    }

    // fork worker
    this.process = fork(settings.exec, settings.args, {
      'env': envCopy,
      'silent': settings.silent,
      'execArgv': settings.execArgv
    });
  } else {
    this.process = process;
  }
  ...
}
</code></pre>

<p>以上代码段印证了之前的推测，就不再赘述了。</p>

<p>还有个细节需要注意：</p>

<pre><code>// src/node.js
if (process.env.NODE_UNIQUE_ID) {
  var cluster = NativeModule.require('cluster');
  cluster._setupWorker();

  // Make sure it's not accidentally inherited by child processes.
  delete process.env.NODE_UNIQUE_ID;
}
</code></pre>

<p>在Node进程启动的时候，子进程会执行以上代码，我们先不追究<code>_setupWorker</code>的细节。可以看到<code>NODE_UNIQUE_ID</code>从环境变量里剔除了，这使得子进程可以作为Master继续复制子进程。</p>

<h3>进程复制</h3>

<p>继续官网的示例，我们先看父进程的执行逻辑：</p>

<pre><code>if (cluster.isMaster) {
  // Fork workers.
  for (var i = 0; i &lt; numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', function(worker, code, signal) {
    console.log('worker ' + worker.process.pid + ' died');
  });
}
</code></pre>

<p>很明显，主要就是执行<code>fork</code>调用。那我们就来看看<code>cluster.fork</code>做了什么？</p>

<pre><code>// Fork a new worker
cluster.fork = function(env) {
  // This can only be called from the master.
  assert(cluster.isMaster);

  // Make sure that the master has been initialized
  cluster.setupMaster();

  return (new cluster.Worker(env));
};
</code></pre>

<p>先<code>setupMaster</code>，再返回一个<code>cluster.Worker</code>实例。其实<code>workder</code>实例化的代码在前面已经贴过了，我们来个完整版：</p>

<pre><code>// Create a worker object, that works both for master and worker
function Worker(customEnv) {
  if (!(this instanceof Worker)) return new Worker();
  EventEmitter.call(this);

  var self = this;
  var env = process.env;

  // Assign a unique id, default null
  this.id = cluster.isMaster ? ++ids : toDecInt(env.NODE_UNIQUE_ID);

  // XXX: Legacy.  Remove in 0.9
  this.workerID = this.uniqueID = this.id;

  // Assign state
  this.state = 'none';

  // Create or get process
  if (cluster.isMaster) {

    // Create env object
    // first: copy and add id property
    var envCopy = util._extend({}, env);
    envCopy['NODE_UNIQUE_ID'] = this.id;
    // second: extend envCopy with the env argument
    if (isObject(customEnv)) {
      envCopy = util._extend(envCopy, customEnv);
    }

    // fork worker
    this.process = fork(settings.exec, settings.args, {
      'env': envCopy,
      'silent': settings.silent,
      'execArgv': settings.execArgv
    });
  } else {
    this.process = process;
  }

  if (cluster.isMaster) {
    // Save worker in the cluster.workers array
    cluster.workers[this.id] = this;

    // Emit a fork event, on next tick
    // There is no worker.fork event since this has no real purpose
    process.nextTick(function() {
      cluster.emit('fork', self);
    });
  }

  // handle internalMessage, exit and disconnect event
  this.process.on('internalMessage', handleMessage.bind(null, this));
  this.process.once('exit', function(exitCode, signalCode) {
    prepareExit(self, 'dead');
    self.emit('exit', exitCode, signalCode);
    cluster.emit('exit', self, exitCode, signalCode);
  });
  this.process.once('disconnect', function() {
    prepareExit(self, 'disconnected');
    self.emit('disconnect');
    cluster.emit('disconnect', self);
  });

  // relay message and error
  this.process.on('message', this.emit.bind(this, 'message'));
  this.process.on('error', this.emit.bind(this, 'error'));

}
</code></pre>

<p>每个worker分配了一个<code>id</code>，注册在<code>cluster.workers</code>里。父进程和子进程注册了一堆事件，这些事件涉及父子进程通讯，我们在下一篇文章里详细讨论。接下来，我们再看看<code>setupMaster</code>做了什么：</p>

<pre><code>cluster.setupMaster = function(options) {
  // This can only be called from the master.
  assert(cluster.isMaster);

  // Don't allow this function to run more than once
  if (masterStarted) return;
  masterStarted = true;

  // Get filename and arguments
  options = options || {};

  // By default, V8 writes the profile data of all processes to a single
  // v8.log.
  //
  // Running that log file through a tick processor produces bogus numbers
  // because many events won't match up with the recorded memory mappings
  // and you end up with graphs where 80+% of ticks is unaccounted for.
  //
  // Fixing the tick processor to deal with multi-process output is not very
  // useful because the processes may be running wildly disparate workloads.
  //
  // That's why we fix up the command line arguments to include
  // a &quot;--logfile=v8-%p.log&quot; argument (where %p is expanded to the PID)
  // unless it already contains a --logfile argument.
  var execArgv = options.execArgv || process.execArgv;
  if (execArgv.some(function(s) { return /^--prof/.test(s); }) &amp;&amp;
      !execArgv.some(function(s) { return /^--logfile=/.test(s); }))
  {
    execArgv = execArgv.slice();
    execArgv.push('--logfile=v8-%p.log');
  }

  // Set settings object
  settings = cluster.settings = {
    exec: options.exec || process.argv[1],
    execArgv: execArgv,
    args: options.args || process.argv.slice(2),
    silent: options.silent || false
  };

  // emit setup event
  cluster.emit('setup');
};
</code></pre>

<p>这里是复制子进程之前的一些准备工作。你可以显示调用这个方法并传入一些配置，主要就是指定子进程的执行入口<code>options.exec</code>，如果像官网例子那样不显式调用，则默认把当前文件作为入口。</p>

<h3>最后</h3>

<p>敬请期待后续文章。</p>

    <hr>
    <div class="pagination">
      <ul>
        <ul>
          
            <li class="prev"><a href="/2014-10-23/peer-dependencies" title="Peer dependencies">&larr; Previous</a></li>
          
          

            <li><a href="/archive">Archive</a></li>

          
            <li class="next"><a href="/2014-07-13/generator-base" title="Generator基础篇">Next &rarr;</a></li>
          
          
        </ul>
      </ul>
    </div>
    <hr>
    
<div id="disqus_thread"></div>
<script>
    var disqus_developer = 1;
    var disqus_shortname = 'jekyllbootstrap'; // required: replace example with your forum shortname
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

  </div>
  
  <div class="span4">
    <h4>Published</h4>
    <div class="date"><span>2014-10-14</span></div>
    <br>
    <h4>Categories</h4>
    <ul class="tag_box">
    
      <li>
  <a href="/categories/#js-ref">js <span>3</span></a>
</li>
    
    </ul>
    <br>
    <h4>Tags</h4>
    <ul class="tag_box">
    
      <li>
  <a href="/tags/#node-ref">node <span>3</span></a>
</li>
    
    </ul>
  </div>
</div>

      </div>

      <footer>
        <p><a href="http://www.miitbeian.gov.cn/" target="_blank">&copy; 浙ICP备15000351号</a></p>
        <p>
          Ruoqi Deng 2013 
          with help from <a href="http://github.com/wendal/gor" target="_blank" title="Gor -- Fast Blog">Gor</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a> 
          and Idea from <a href="http://ruhoh.com" target="_blank" title="The Definitive Technical Blogging Framework">ruhoh</a>
        </p>
      </footer>

    </div> <!-- /container -->

    
<script src="//cdnjscn.b0.upaiyun.com/libs/prettify/r298/prettify.min.js"></script>
<script>
  var pres = document.getElementsByTagName("pre");
  for (var i=0; i < pres.length; ++i) {
    pres[i].className = "prettyprint linenums";
  }
  prettyPrint();
</script>

    
<script type="text/javascript">

  var _gaq = _gaq || [];
  var pluginUrl = '//www.google-analytics.com/plugins/ga/inpage_linkid.js';
  _gaq.push(['_require', 'inpage_linkid', pluginUrl]);
  _gaq.push(['_setAccount', 'UA-42808195-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
  </body>
</html>
