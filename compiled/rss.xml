<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>Lucky Blog</title>
    <link>http://luckydrq.com</link>
    <pubDate>06 Jan 15 23:21 CST</pubDate>
    <item>
      <title>配置git的commit_message模板</title>
      <link>http://luckydrq.com/2014-12-04/git-commit-message</link>
      <pubDate>2014-12-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;我们平时用&lt;code&gt;git&lt;/code&gt;或&lt;code&gt;svn&lt;/code&gt;提交代码的时候，&lt;code&gt;commit message&lt;/code&gt;都是跟在&lt;code&gt;-m&lt;/code&gt;后面直接在命令行里打出来，这样确实很方便。但是，当我们参与大型或者正式的多人合作的项目时，在版本管理或分支策略上会有一些标准规范，其中可能也会包括对&lt;code&gt;commit message&lt;/code&gt;进行规范。例如，我在做&lt;a href=&#34;http://gitlab.alibaba-inc.com/icbu-node/columbus&#34;&gt;哥伦布&lt;/a&gt;的时候，项目组就制定了一些&lt;a href=&#34;http://gitlab.alibaba-inc.com/icbu-node/columbus/issues/37&#34;&gt;规范&lt;/a&gt;。具体来说，比如&lt;code&gt;commit message&lt;/code&gt;的格式要求如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;&#xA;&amp;lt;BLANK LINE&amp;gt;&#xA;&amp;lt;body&amp;gt;&#xA;&amp;lt;BLANK LINE&amp;gt;&#xA;&amp;lt;footer&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;看起来很专业，但格式有点复杂，还要记住&lt;code&gt;type&lt;/code&gt;，&lt;code&gt;scope&lt;/code&gt;，&lt;code&gt;body&lt;/code&gt;，&lt;code&gt;footer&lt;/code&gt;都是干什么用的，具体有哪些值，实施起来有点抵触心理。于是就想，最好每次提交的时候都能看到这些东西，这样就能参考着写了，也不需要花太多精力去记忆。经过google，发现可以配置&lt;code&gt;message template&lt;/code&gt;。步骤如下：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;配置默认编辑器，以macvim为例：&lt;code&gt;git config --global core.editor &amp;quot;mvim -f&amp;quot;&lt;/code&gt;。&lt;em&gt;注意：mvim 一定要带上&lt;code&gt;-f&lt;/code&gt;标志。&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;把&lt;code&gt;message template&lt;/code&gt;放在一个文件里，例如&lt;code&gt;$HOME/.gitmessage&lt;/code&gt;。配置&lt;code&gt;git commit&lt;/code&gt;时读取该文件作为模板：&lt;code&gt;git config --global commit.template $HOME/.gitmessage&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;$HOME/.gitmessage&lt;/code&gt;所有内容行以&lt;code&gt;#&lt;/code&gt;开头，这是注释，提交时会被&lt;code&gt;git&lt;/code&gt;忽略。以上面提及的规范为例，文件内容如下：&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# https://github.com/angular/angular.js/blob/master/CONTRIBUTING.md#commit-message-format&#xA;#&#xA;# Format:&#xA;#&#xA;# &amp;lt;type&amp;gt;(&amp;lt;scope&amp;gt;): &amp;lt;subject&amp;gt;&#xA;# &amp;lt;BLANK LINE&amp;gt;&#xA;# &amp;lt;body&amp;gt;&#xA;# &amp;lt;BLANK LINE&amp;gt;&#xA;# &amp;lt;footer&amp;gt;&#xA;#&#xA;# Type:&#xA;#&#xA;# feat: A new feature&#xA;# fix: A buf fix&#xA;# docs: Documentation only changes&#xA;# style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)&#xA;# refactor: A code change that neither fixes a bug or adds a feature&#xA;# perf: A code change that improves performance&#xA;# test: Adding missing tests&#xA;# chore: Changes to the build process or auxiliary tools and libraries such as documentation generation&#xA;#&#xA;# Scope:&#xA;#&#xA;# The scope could be anything specifying place of the commit change.&#xA;#&#xA;# Body:&#xA;#&#xA;# Just as in the subject, use the imperative, present tense: &amp;quot;change&amp;quot; not &amp;quot;changed&amp;quot; nor &amp;quot;changes&amp;quot; The body should include the motivation for the change and contrast this with previous behavior.&#xA;#&#xA;# Footer:&#xA;#&#xA;# The footer should contain any information about Breaking Changes and is also the place to reference GitHub issues that this commit Closes.&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;根据实际情况，你可以增加详尽的注释。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;全文完。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>XST攻击浅析</title>
      <link>http://luckydrq.com/2014-11-06/xst-attack</link>
      <pubDate>2014-11-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近在考虑node项目里web安全相关的问题，公司的安全同学要求在生产环境禁用&lt;code&gt;HTTP TRACE&lt;/code&gt;。于是就研究了一下，发现利用&lt;code&gt;TRACE&lt;/code&gt;攻击一旦得手的话，风险会很大。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;cross-site-tracing&#34; href=&#34;#cross-site-tracing&#34;&gt;&lt;/a&gt;Cross-Site Tracing&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;XST的全称是&lt;code&gt;Cross-Site Tracing&lt;/code&gt;，名称上和我们熟知的&lt;code&gt;XSS&lt;/code&gt;(Cross-Site Scripting)很相似。但两者其实是没有什么关系的。客户端发&lt;code&gt;TRACE&lt;/code&gt;请求至服务器，如果服务器按照&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&#34;&gt;标准&lt;/a&gt;实现了TRACE响应，则在&lt;code&gt;response body&lt;/code&gt;里会返回此次请求的完整头信息。通过这种方式，客户端可以获取某些敏感的头字段，例如&lt;code&gt;httpOnly&lt;/code&gt;的cookie。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面我们基于koa来实现一个简单的支持&lt;code&gt;TRACE&lt;/code&gt;方法的服务器：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var koa = require(&#39;koa&#39;);&#xA;var app = koa();&#xA;&#xA;app.use(function* (next) {&#xA;  this.cookies.set(&#39;a&#39;, 1, { httpOnly: true });&#xA;  if (this.method === &#39;TRACE&#39;) {&#xA;    var body = &#39;&#39;;&#xA;    for (header in this.headers) {&#xA;      body += header + &#39;: &#39; + this.headers[header] + &#39;\r\n&#39;;&#xA;    }&#xA;    this.body = body;&#xA;  }&#xA;  yield* next;&#xA;});&#xA;&#xA;app.listen(7001);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;启动服务后，先发个GET请求 &lt;code&gt;curl -i http://127.0.0.1:7001&lt;/code&gt;，得到如下响应：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK&#xA;X-Powered-By: koa&#xA;Set-Cookie: a=1; path=/; httponly&#xA;Content-Type: text/plain; charset=utf-8&#xA;Content-Length: 2&#xA;Date: Thu, 06 Nov 2014 05:04:42 GMT&#xA;Connection: keep-alive&#xA;&#xA;OK&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;服务器设置了一个&lt;code&gt;httpOnly&lt;/code&gt;的cookie&lt;code&gt;a=1&lt;/code&gt;，在浏览器环境中，是无法通过脚本获取它的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;接着我们发&lt;code&gt;TRACE&lt;/code&gt;请求到服务器&lt;code&gt;curl -X TRACE -b a=1 -i http://127.0.0.1:7001&lt;/code&gt;，并带上cookie，得到如下响应：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;HTTP/1.1 200 OK&#xA;X-Powered-By: koa&#xA;Set-Cookie: a=1; path=/; httponly&#xA;Content-Type: text/plain; charset=utf-8&#xA;Content-Length: 73&#xA;Date: Thu, 06 Nov 2014 05:07:47 GMT&#xA;Connection: keep-alive&#xA;&#xA;user-agent: curl/7.37.1&#xA;host: 127.0.0.1:7001&#xA;accept: */*&#xA;cookie: a=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在响应体里可以看到完整的头信息，这样我们就绕过了&lt;code&gt;httpOnly&lt;/code&gt;的限制，拿到了cookie&lt;code&gt;a=1&lt;/code&gt;，造成了很大的风险。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;应对策略&#34; href=&#34;#应对策略&#34;&gt;&lt;/a&gt;应对策略&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;目前主流的浏览器在xhr请求里都禁止了&lt;code&gt;TRACE&lt;/code&gt;方法，一定程度上降低了风险。但是，第三方插件如flash，仍存在可以发&lt;code&gt;TRACE&lt;/code&gt;请求的风险。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，无论如何请禁用&lt;code&gt;TRACE&lt;/code&gt;方法。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;reference&#34; href=&#34;#reference&#34;&gt;&lt;/a&gt;Reference&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&#34;&gt;http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html&lt;/a&gt;&#xA;&lt;a href=&#34;http://deadliestwebattacks.com/2010/05/18/cross-site-tracing-xst-the-misunderstood-vulnerability/&#34;&gt;http://deadliestwebattacks.com/&lt;sup&gt;2010&lt;/sup&gt;&amp;frasl;&lt;sub&gt;05&lt;/sub&gt;/18/cross-site-tracing-xst-the-misunderstood-vulnerability/&lt;/a&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>计时攻击浅析</title>
      <link>http://luckydrq.com/2014-10-27/timing-attack</link>
      <pubDate>2014-10-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天在扒代码的时候看到有个cookie验证的&lt;a href=&#34;https://github.com/expressjs/keygrip&#34;&gt;模块&lt;/a&gt;，它的原理就是通过对cookie进行签名和验签。不过，其中有个小模块&lt;a href=&#34;https://github.com/freewil/scmp&#34;&gt;scmp&lt;/a&gt;引起了我的注意，经过google才知道“计时攻击”（Timing Attack）这么个东西，看来安全方面自己还有很多东西要补。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;看代码&#34; href=&#34;#看代码&#34;&gt;&lt;/a&gt;看代码&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;scmp模块代码很少，如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;module.exports = function scmp(a, b) {&#xA;  a = String(a);&#xA;  b = String(b);&#xA;  if (a.length !== b.length) {&#xA;    return false;&#xA;  }&#xA;  var result = 0;&#xA;  for (var i = 0; i &amp;lt; a.length; ++i) {&#xA;    result |= a.charCodeAt(i) ^ b.charCodeAt(i);&#xA;  }&#xA;  return result === 0;&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这就是个字符串比较的函数啊，有什么稀奇的。但仔细一看实现过程，是不是有点蛋疼？！直接&lt;code&gt;return a == b&lt;/code&gt;不就行了。这里就要说下什么是计时攻击。&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;计时攻击 属于旁路攻击的一种, 所谓旁路攻击就是通过对系统的物理学分析和实现方式分析, 而不是密码学分析或暴力破解, 来尝试破解密码学系统的行为.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;怎么理解？&#34; href=&#34;#怎么理解？&#34;&gt;&lt;/a&gt;怎么理解？&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;如果直接以&lt;code&gt;a == b&lt;/code&gt;作为条件来判断，大多数实现会对字符串进行逐字节匹配，如果发现有不匹配的，则立刻返回&lt;code&gt;false&lt;/code&gt;。这样，比较的快慢就与字符串的顺序匹配度成反比，直接结果反应在响应时间上（虽然这些都是微妙级的）。通过大量的数据采集，就有可能推测出推测出明文。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;现在，你应该理解上面的代码为啥要这样写了。因为它对字符串的每个位都比较一遍，所以响应时间几乎是常量（constant-time）。这种比较方式在性能上也许有些损耗，但最大程度上杜绝计时攻击。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;感想&#34; href=&#34;#感想&#34;&gt;&lt;/a&gt;感想&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这种攻击要得手的话，对时间的要求也太苛刻了吧，会受到很多因素干扰，感觉很不靠谱，哈哈。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;参考文章&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://codahale.com/a-lesson-in-timing-attacks/&#34;&gt;http://codahale.com/a-lesson-in-timing-attacks/&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://ruby-china.org/topics/21380&#34;&gt;https://ruby-china.org/topics/21380&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
    </item>
    <item>
      <title>Peer dependencies</title>
      <link>http://luckydrq.com/2014-10-23/peer-dependencies</link>
      <pubDate>2014-10-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;众所周知，nodejs通过包管理工具&lt;code&gt;npm&lt;/code&gt;来解决包之间的依赖问题。对此，大家最熟悉的可能就是&lt;code&gt;package.json&lt;/code&gt;文件的&lt;code&gt;dependencies&lt;/code&gt;和&lt;code&gt;devDependencies&lt;/code&gt;两个字段：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;dependencies：当前包强依赖的三方包（没有它们就不能work了）&lt;/li&gt;&#xA;&lt;li&gt;devDependencies：当前包开发或者测试依赖的三方包（没有它们也能work）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;今天就来解析下另外一个字段：&lt;code&gt;peerDependencies&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;通常情况&#34; href=&#34;#通常情况&#34;&gt;&lt;/a&gt;通常情况&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;先来看一个普通的例子：我的包依赖&lt;code&gt;a@2.0.0&lt;/code&gt;和&lt;code&gt;b@1.2.3&lt;/code&gt;两个包，而&lt;code&gt;b@1.2.3&lt;/code&gt;又依赖&lt;code&gt;a@1.0.0&lt;/code&gt;，那么最终的依赖关系是这样的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;├── a@2.0.0&#xA;├── b@1.2.3&#xA;│   ├── a@1.0.0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;npm&lt;/code&gt;可以很好地解决上述问题，&lt;code&gt;a@1.0.0&lt;/code&gt;只供&lt;code&gt;b&lt;/code&gt;使用，不会影响到&lt;code&gt;a@2.0.0&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;问题场景&#34; href=&#34;#问题场景&#34;&gt;&lt;/a&gt;问题场景&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;npm&lt;/code&gt;生态里有一些包是用作&lt;code&gt;插件(plugins)&lt;/code&gt;的，它们的运行依赖&lt;code&gt;宿主(host package)&lt;/code&gt;。例如，&lt;code&gt;grunt-contrib-uglify&lt;/code&gt;和&lt;code&gt;grunt&lt;/code&gt;就是插件和宿主的关系。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以下罗列了一些常见的插件体系：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://gruntjs.com/#plugins-all&#34;&gt;Grunt plugins&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://chaijs.com/plugins&#34;&gt;Chai plugins&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/rvagg/node-levelup/wiki/Modules&#34;&gt;LevelUP plugins&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;http://expressjs.com/api.html#middleware&#34;&gt;Express middleware&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/flatiron/winston/blob/master/docs/transports.md&#34;&gt;Winston transports&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;通常情况下，插件是基于宿主的某个特定版本之上设计与开发的，而大多数插件本身并不依赖宿主（以grunt插件为例，它们的代码里不会&lt;code&gt;require(&#39;grunt&#39;)&lt;/code&gt;，&lt;code&gt;dependencies&lt;/code&gt;字段里也不会写上&lt;code&gt;grunt&lt;/code&gt;包依赖）。这样就会导致插件A依赖的宿主版本与插件B依赖的宿主版本不一致。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;即使插件对宿主有强依赖，例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;├── winston@0.6.2&#xA;├── winston-mail@0.2.3&#xA;│   ├── winston@0.5.11&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;宿主包因为版本差异导致的API差异，仍然可能导致问题。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;&lt;a style=&#34;display: block;&#34; name=&#34;peerdependencies&#34; href=&#34;#peerdependencies&#34;&gt;&lt;/a&gt;peerDependencies&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在插件的&lt;code&gt;package.json&lt;/code&gt;里加入&lt;code&gt;peerDependencies&lt;/code&gt;描述，就好像在说“我只能在宿主1.2.x版本之上正常工作，如果要安装我，请务必确认宿主的版本兼容性”。如果插件A和插件B指定的宿主版本造成了冲突（这里的冲突不是指&lt;code&gt;patch&lt;/code&gt;版本冲突，而是&lt;code&gt;major&lt;/code&gt;或者&lt;code&gt;minor&lt;/code&gt;的版本，具体的验证逻辑没有详细考证，详见&lt;a href=&#34;http://semver.org/&#34;&gt;semver&lt;/a&gt;），npm 会报错提示。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;以下是&lt;code&gt;grunt-contrib-uglify&lt;/code&gt;插件的包描述的一部分：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;quot;dependencies&amp;quot;: {&#xA;   &amp;quot;chalk&amp;quot;: &amp;quot;^0.5.1&amp;quot;,&#xA;   &amp;quot;lodash&amp;quot;: &amp;quot;^2.4.1&amp;quot;,&#xA;   &amp;quot;maxmin&amp;quot;: &amp;quot;^1.0.0&amp;quot;,&#xA;   &amp;quot;uglify-js&amp;quot;: &amp;quot;^2.4.0&amp;quot;,&#xA;   &amp;quot;uri-path&amp;quot;: &amp;quot;0.0.2&amp;quot;&#xA;},&#xA;&#xA;...&#xA;&#xA;&amp;quot;peerDependencies&amp;quot;: {&#xA;  &amp;quot;grunt&amp;quot;: &amp;quot;~0.4.0&amp;quot;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;当&lt;code&gt;npm install grunt-contrib-uglify&lt;/code&gt;时，&lt;code&gt;grunt&lt;/code&gt;也会被安装：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;├── grunt&#xA;├── grunt-contrib-uglify&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;grunt&lt;/code&gt;与&lt;code&gt;grunt-contrib-uglify&lt;/code&gt;目录是平级的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;需要注意的是，&lt;code&gt;peerDependencies&lt;/code&gt;不应规定得太死。例如，不应&lt;code&gt;grunt: &amp;quot;0.4.1&amp;quot;&lt;/code&gt;，而应该&lt;code&gt;grunt: 0.4.x&lt;/code&gt;或者&lt;code&gt;grunt: ~0.4.0&lt;/code&gt;，这样提供了更多的包容性，毕竟很多插件开发者都懒得搞清楚兼容的最低宿主版本。&lt;/strong&gt;&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Cluster机制剖析1——进程复制</title>
      <link>http://luckydrq.com/2014-10-14/cluster-analyse-one</link>
      <pubDate>2014-10-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Cluster相信大家都很熟悉，这里就不再赘述了，引用官网的一段话：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;A single instance of Node runs in a single thread. To take advantage of multi-core systems the user will sometimes want to launch a cluster of Node processes to handle the load.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;本文将基于&lt;code&gt;node_v0.10.32&lt;/code&gt;来八一八它的实现原理。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Fork&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Fork_(system_call&#34;&gt;fork()&lt;/a&gt;是类UNIX系统父进程复制子进程的系统调用，在Node里通过&lt;a href=&#34;https://github.com/joyent/libuv&#34;&gt;libuv&lt;/a&gt;实现了对不同平台(unix,linux,windows)的封装。引用&lt;a href=&#34;http://baike.baidu.com/view/1952900.htm&#34;&gt;百度百科&lt;/a&gt;的一段话来描述&lt;code&gt;fork&lt;/code&gt;的特性：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;fork之后的子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;其实，在node的&lt;code&gt;cluster&lt;/code&gt;模式里，worker进程的产生也是调用了&lt;code&gt;require(&#39;child_process&#39;).fork&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;那直接这样不就行了？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var fork = require(&#39;child_process&#39;).fork;&#xA;var cpuNums = require(&#39;os&#39;).cpus().length;&#xA;var workerPath = require(&#39;path&#39;).join(__dirname, &#39;worker.js&#39;); &#xA;&#xA;for (var i = 0; i &amp;lt; cpuNums; i++) {&#xA;  fork(workerPath, { env: process.env });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样的方式仅仅实现了多进程。多进程运行还涉及&lt;strong&gt;父子进程通信，子进程管理，以及负载均衡&lt;/strong&gt;等问题，这些特性&lt;code&gt;cluster&lt;/code&gt;帮你实现了，在后面的章节会一一道来。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;两种逻辑&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;先看一个官网的例子：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var cluster = require(&#39;cluster&#39;);&#xA;var http = require(&#39;http&#39;);&#xA;var numCPUs = require(&#39;os&#39;).cpus().length;&#xA;&#xA;if (cluster.isMaster) {&#xA;  // Fork workers.&#xA;  for (var i = 0; i &amp;lt; numCPUs; i++) {&#xA;    cluster.fork();&#xA;  }&#xA;&#xA;  cluster.on(&#39;exit&#39;, function(worker, code, signal) {&#xA;    console.log(&#39;worker &#39; + worker.process.pid + &#39; died&#39;);&#xA;  });&#xA;} else {&#xA;  // Workers can share any TCP connection&#xA;  // In this case its a HTTP server&#xA;  http.createServer(function(req, res) {&#xA;    res.writeHead(200);&#xA;    res.end(&amp;quot;hello world\n&amp;quot;);&#xA;  }).listen(8000);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以上代码的意思是：如果是父进程（Master），就复制多个子进程，子进程的数目等于CPU核心数。如果是子进程（Worker），就创建一个http服务器并监听8000端口。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们在前面提到，子进程是父进程的“副本”，将得到父进程的数据（代码）空间及堆栈，因此，父子进程会执行&lt;strong&gt;同一段代码逻辑&lt;/strong&gt;。这样就需要一种机制，能够在代码里区分当前进程是父进程还是子进程。首先来看看神秘的&lt;code&gt;cluster&lt;/code&gt;模块究竟是什么：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// lib/cluster.js&#xA;&#xA;function Cluster() {&#xA;  EventEmitter.call(this);&#xA;}&#xA;&#xA;util.inherits(Cluster, EventEmitter);&#xA;&#xA;var cluster = module.exports = new Cluster();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;它是一个&lt;code&gt;Object&lt;/code&gt;，通过继承&lt;code&gt;EventEmitter&lt;/code&gt;，使它有了事件驱动机制。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Define isWorker and isMaster&#xA;cluster.isWorker = &#39;NODE_UNIQUE_ID&#39; in process.env;&#xA;cluster.isMaster = ! cluster.isWorker;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以看到&lt;code&gt;cluster&lt;/code&gt;下有两个flag来标识区分当前进程，依据是当前进程的环境变量（&lt;code&gt;env&lt;/code&gt;）里是否包含&lt;code&gt;NODE_UNIQUE_ID&lt;/code&gt;这个字段。&lt;strong&gt;为什么子进程的环境变量里有这个字段而父进程没有？&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们知道，在复制子进程的时候实际上是调用了&lt;code&gt;require(&#39;child_process&#39;).fork&lt;/code&gt;，看一下这个方法的用法：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;child_process.fork(modulePath, [args], [options])&#xA;  modulePath String The module to run in the child&#xA;  args Array List of string arguments&#xA;  options Object&#xA;    cwd String Current working directory of the child process&#xA;    env Object Environment key-value pairs&#xA;    encoding String (Default: &#39;utf8&#39;)&#xA;    execPath String Executable used to create the child process&#xA;    execArgv Array List of string arguments passed to the executable (Default: process.execArgv)&#xA;    silent Boolean If true, stdin, stdout, and stderr of the child will be piped to the parent, otherwise they will be inherited from the parent, see the &amp;quot;pipe&amp;quot; and &amp;quot;inherit&amp;quot; options for spawn()&#39;s stdio for more details (default is false)&#xA;  Return: ChildProcess object&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以看到方法的第三个参数&lt;code&gt;options&lt;/code&gt;是个对象，其中&lt;code&gt;options.env&lt;/code&gt;可以设置子进程的环境变量，即&lt;code&gt;process.env&lt;/code&gt;。因此，可以推测，应该是这里调用的时候，在env里面添加了&lt;code&gt;NODE_UNIQUE_ID&lt;/code&gt;这个标识。接下来就来看下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;function Worker(customEnv) {&#xA;  ...&#xA;  // Create or get process&#xA;  if (cluster.isMaster) {&#xA;&#xA;    // Create env object&#xA;    // first: copy and add id property&#xA;    var envCopy = util._extend({}, env);&#xA;    envCopy[&#39;NODE_UNIQUE_ID&#39;] = this.id;&#xA;    // second: extend envCopy with the env argument&#xA;    if (isObject(customEnv)) {&#xA;      envCopy = util._extend(envCopy, customEnv);&#xA;    }&#xA;&#xA;    // fork worker&#xA;    this.process = fork(settings.exec, settings.args, {&#xA;      &#39;env&#39;: envCopy,&#xA;      &#39;silent&#39;: settings.silent,&#xA;      &#39;execArgv&#39;: settings.execArgv&#xA;    });&#xA;  } else {&#xA;    this.process = process;&#xA;  }&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以上代码段印证了之前的推测，就不再赘述了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;还有个细节需要注意：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// src/node.js&#xA;if (process.env.NODE_UNIQUE_ID) {&#xA;  var cluster = NativeModule.require(&#39;cluster&#39;);&#xA;  cluster._setupWorker();&#xA;&#xA;  // Make sure it&#39;s not accidentally inherited by child processes.&#xA;  delete process.env.NODE_UNIQUE_ID;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在Node进程启动的时候，子进程会执行以上代码，我们先不追究&lt;code&gt;_setupWorker&lt;/code&gt;的细节。可以看到&lt;code&gt;NODE_UNIQUE_ID&lt;/code&gt;从环境变量里剔除了，这使得子进程可以作为Master继续复制子进程。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;进程复制&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;继续官网的示例，我们先看父进程的执行逻辑：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if (cluster.isMaster) {&#xA;  // Fork workers.&#xA;  for (var i = 0; i &amp;lt; numCPUs; i++) {&#xA;    cluster.fork();&#xA;  }&#xA;&#xA;  cluster.on(&#39;exit&#39;, function(worker, code, signal) {&#xA;    console.log(&#39;worker &#39; + worker.process.pid + &#39; died&#39;);&#xA;  });&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;很明显，主要就是执行&lt;code&gt;fork&lt;/code&gt;调用。那我们就来看看&lt;code&gt;cluster.fork&lt;/code&gt;做了什么？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Fork a new worker&#xA;cluster.fork = function(env) {&#xA;  // This can only be called from the master.&#xA;  assert(cluster.isMaster);&#xA;&#xA;  // Make sure that the master has been initialized&#xA;  cluster.setupMaster();&#xA;&#xA;  return (new cluster.Worker(env));&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;先&lt;code&gt;setupMaster&lt;/code&gt;，再返回一个&lt;code&gt;cluster.Worker&lt;/code&gt;实例。其实&lt;code&gt;workder&lt;/code&gt;实例化的代码在前面已经贴过了，我们来个完整版：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;// Create a worker object, that works both for master and worker&#xA;function Worker(customEnv) {&#xA;  if (!(this instanceof Worker)) return new Worker();&#xA;  EventEmitter.call(this);&#xA;&#xA;  var self = this;&#xA;  var env = process.env;&#xA;&#xA;  // Assign a unique id, default null&#xA;  this.id = cluster.isMaster ? ++ids : toDecInt(env.NODE_UNIQUE_ID);&#xA;&#xA;  // XXX: Legacy.  Remove in 0.9&#xA;  this.workerID = this.uniqueID = this.id;&#xA;&#xA;  // Assign state&#xA;  this.state = &#39;none&#39;;&#xA;&#xA;  // Create or get process&#xA;  if (cluster.isMaster) {&#xA;&#xA;    // Create env object&#xA;    // first: copy and add id property&#xA;    var envCopy = util._extend({}, env);&#xA;    envCopy[&#39;NODE_UNIQUE_ID&#39;] = this.id;&#xA;    // second: extend envCopy with the env argument&#xA;    if (isObject(customEnv)) {&#xA;      envCopy = util._extend(envCopy, customEnv);&#xA;    }&#xA;&#xA;    // fork worker&#xA;    this.process = fork(settings.exec, settings.args, {&#xA;      &#39;env&#39;: envCopy,&#xA;      &#39;silent&#39;: settings.silent,&#xA;      &#39;execArgv&#39;: settings.execArgv&#xA;    });&#xA;  } else {&#xA;    this.process = process;&#xA;  }&#xA;&#xA;  if (cluster.isMaster) {&#xA;    // Save worker in the cluster.workers array&#xA;    cluster.workers[this.id] = this;&#xA;&#xA;    // Emit a fork event, on next tick&#xA;    // There is no worker.fork event since this has no real purpose&#xA;    process.nextTick(function() {&#xA;      cluster.emit(&#39;fork&#39;, self);&#xA;    });&#xA;  }&#xA;&#xA;  // handle internalMessage, exit and disconnect event&#xA;  this.process.on(&#39;internalMessage&#39;, handleMessage.bind(null, this));&#xA;  this.process.once(&#39;exit&#39;, function(exitCode, signalCode) {&#xA;    prepareExit(self, &#39;dead&#39;);&#xA;    self.emit(&#39;exit&#39;, exitCode, signalCode);&#xA;    cluster.emit(&#39;exit&#39;, self, exitCode, signalCode);&#xA;  });&#xA;  this.process.once(&#39;disconnect&#39;, function() {&#xA;    prepareExit(self, &#39;disconnected&#39;);&#xA;    self.emit(&#39;disconnect&#39;);&#xA;    cluster.emit(&#39;disconnect&#39;, self);&#xA;  });&#xA;&#xA;  // relay message and error&#xA;  this.process.on(&#39;message&#39;, this.emit.bind(this, &#39;message&#39;));&#xA;  this.process.on(&#39;error&#39;, this.emit.bind(this, &#39;error&#39;));&#xA;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;每个worker分配了一个&lt;code&gt;id&lt;/code&gt;，注册在&lt;code&gt;cluster.workers&lt;/code&gt;里。父进程和子进程注册了一堆事件，这些事件涉及父子进程通讯，我们在下一篇文章里详细讨论。接下来，我们再看看&lt;code&gt;setupMaster&lt;/code&gt;做了什么：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cluster.setupMaster = function(options) {&#xA;  // This can only be called from the master.&#xA;  assert(cluster.isMaster);&#xA;&#xA;  // Don&#39;t allow this function to run more than once&#xA;  if (masterStarted) return;&#xA;  masterStarted = true;&#xA;&#xA;  // Get filename and arguments&#xA;  options = options || {};&#xA;&#xA;  // By default, V8 writes the profile data of all processes to a single&#xA;  // v8.log.&#xA;  //&#xA;  // Running that log file through a tick processor produces bogus numbers&#xA;  // because many events won&#39;t match up with the recorded memory mappings&#xA;  // and you end up with graphs where 80+% of ticks is unaccounted for.&#xA;  //&#xA;  // Fixing the tick processor to deal with multi-process output is not very&#xA;  // useful because the processes may be running wildly disparate workloads.&#xA;  //&#xA;  // That&#39;s why we fix up the command line arguments to include&#xA;  // a &amp;quot;--logfile=v8-%p.log&amp;quot; argument (where %p is expanded to the PID)&#xA;  // unless it already contains a --logfile argument.&#xA;  var execArgv = options.execArgv || process.execArgv;&#xA;  if (execArgv.some(function(s) { return /^--prof/.test(s); }) &amp;amp;&amp;amp;&#xA;      !execArgv.some(function(s) { return /^--logfile=/.test(s); }))&#xA;  {&#xA;    execArgv = execArgv.slice();&#xA;    execArgv.push(&#39;--logfile=v8-%p.log&#39;);&#xA;  }&#xA;&#xA;  // Set settings object&#xA;  settings = cluster.settings = {&#xA;    exec: options.exec || process.argv[1],&#xA;    execArgv: execArgv,&#xA;    args: options.args || process.argv.slice(2),&#xA;    silent: options.silent || false&#xA;  };&#xA;&#xA;  // emit setup event&#xA;  cluster.emit(&#39;setup&#39;);&#xA;};&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里是复制子进程之前的一些准备工作。你可以显示调用这个方法并传入一些配置，主要就是指定子进程的执行入口&lt;code&gt;options.exec&lt;/code&gt;，如果像官网例子那样不显式调用，则默认把当前文件作为入口。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;最后&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;敬请期待后续文章。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>Generator基础篇</title>
      <link>http://luckydrq.com/2014-07-13/generator-base</link>
      <pubDate>2014-07-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;众所周知，&lt;a href=&#34;http://wiki.ecmascript.org/doku.php?id=harmony:generators&#34;&gt;Generator&lt;/a&gt;是&lt;code&gt;ES6&lt;/code&gt;的新特性，通过&lt;code&gt;yield&lt;/code&gt;关键字，可以让函数的执行流挂起。本文对&lt;code&gt;Generator&lt;/code&gt;的基本特性进行介绍，若&#xA;有错误请指正。(注：本文的代码在node v0.11.9下运行，node下的实现和标准有些偏差，文中将会进行注释)&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Generator和Generator Object&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;什么是Generator?&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  function *gen(){&#xA;    yield 1;&#xA;  };&#xA;&#xA;  console.log(typeof gen);           // function&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样就完成了一个&lt;code&gt;Generator&lt;/code&gt;的声明，它是一个函数。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如何判断一个函数是否&lt;code&gt;Generator&lt;/code&gt;？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  function isGen(fn) {&#xA;    return &#39;function&#39; === typeof fn&#xA;          &amp;amp;&amp;amp; fn.constructor.name === &#39;GeneratorFunction&#39;;&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;什么是Generator Object？&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  function *gen(){}&#xA;&#xA;  var g = gen();&#xA;  console.log(typeof g);  // object&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;g&lt;/code&gt;是一个&lt;code&gt;Generator Object&lt;/code&gt;，它是一个对象，&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.7#Generators&#34;&gt;MDN&lt;/a&gt;上也称它为&lt;code&gt;generator-iterator&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Hello World&lt;/h3&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  function *gen() {&#xA;    yield &#39;Hello&#39;;&#xA;    yield &#39;World&#39;;&#xA;  }&#xA;&#xA;  var g = gen();&#xA;  console.log(g.next());    // {value: &#39;Hello&#39;, done: false}&#xA;  console.log(g.next());    // {value: &#39;World&#39;, done: false}&#xA;  console.log(g.next());    // {value: undefined, done: true}&#xA;  console.log(g.next());    // Error: Generator has already finished&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;gen()&lt;/code&gt;生成一个&lt;code&gt;Generator Object&lt;/code&gt;并赋值给&lt;code&gt;g&lt;/code&gt;，此时函数体尚未开始执行。&#xA;第一次调用&lt;code&gt;g.next&lt;/code&gt;时，函数体开始执行，直到遇到第一个&lt;code&gt;yield&lt;/code&gt;语句，执行流挂起(suspend)，同时返回一个&lt;code&gt;Object&lt;/code&gt;对象。&#xA;这个对象有&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;done&lt;/code&gt;两个key，&lt;code&gt;value&lt;/code&gt;表示&lt;code&gt;yield&lt;/code&gt;语句后面的表达式的值（&amp;rsquo;hello&amp;rsquo;），&lt;code&gt;done&lt;/code&gt;是个布尔值，表示函数体是否已经执行结束。&#xA;再次调用&lt;code&gt;g.next&lt;/code&gt;时，执行流在挂起的地方继续执行，直到遇到第2个&lt;code&gt;yield&lt;/code&gt;，依次类推。。&#xA;经过2次调用，函数体已经执行到了末尾，此时函数处于挂起状态，还没有跳出，因此&lt;code&gt;done&lt;/code&gt;的值仍是&lt;code&gt;false&lt;/code&gt;。&#xA;再次调用&lt;code&gt;g.next&lt;/code&gt;，（函数体）才执行完毕。这里值得注意的是，每次调用&lt;code&gt;g.next&lt;/code&gt;，执行流在原来挂起的地方继续执行，此时函数的参数、变量都保存着上一次执行的状态和值，就好像函数从未挂起或跳出过。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;一个经典的例子&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;引用&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.7#Generators&#34;&gt;MDN&lt;/a&gt;上的一个示例：斐波那契数列的生成。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  function do_callback(num) {&#xA;    console.log(num);&#xA;  }&#xA;&#xA;  function fib(done) {&#xA;    var i = 0, j = 1, n = 0;&#xA;    while (n &amp;lt; 10) {&#xA;      done(i);&#xA;      var t = i;&#xA;      i = j;&#xA;      j += t;&#xA;      n++;&#xA;    }&#xA;  }&#xA;&#xA;  fib(do_callback);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以上代码与MDN上实现的稍有不同，但意思是一样的：每次迭代的值都会传给一个回调函数。&#xA;这样看起来很正常，会打印出数列的前10个数字。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一个更好的实现：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  function *fib() {&#xA;    var i = 0, j = 1;&#xA;    while (true) {&#xA;      yield i;&#xA;      var t = i;&#xA;      i = j;&#xA;      j += t;&#xA;    }&#xA;  }&#xA;&#xA;  var g = fib();&#xA;  for (var i = 0; i &amp;lt; 10; i++) {&#xA;    console.log(g.next().value);&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;为什么是更好的实现？我有两个理由：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、执行流更清晰。我们的最终目的是要打印出数列，而&lt;code&gt;fib&lt;/code&gt;只是在这个过程中的一个子过程。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2、更加灵活。通过&lt;code&gt;Generator&lt;/code&gt;，我们可以随时继续或停止数列的生成。而第一种方式，则需要给&lt;code&gt;fib&lt;/code&gt;函数增加一个参数以标识所需生成的数列长度，增加了&#xA;代码的复杂性。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;还有什么？&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在&lt;a href=&#34;http://wiki.ecmascript.org/doku.php?id=harmony:generators&#34;&gt;规范&lt;/a&gt;里，一个&lt;code&gt;Generator Object&lt;/code&gt;有4个属性：&#xA;&lt;code&gt;send&lt;/code&gt;、&lt;code&gt;next&lt;/code&gt;、&lt;code&gt;throw&lt;/code&gt;、&lt;code&gt;close&lt;/code&gt;。&lt;code&gt;next&lt;/code&gt;相信大家已经很熟了，下面我们就来八一八其他3个属性。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;.send()&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;send&lt;/code&gt;方法允许指定一个值，作为上一次&lt;code&gt;yield&lt;/code&gt;的返回值。啥意思呢？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  function *gen() {&#xA;    var x = yield 1;&#xA;    yield x;&#xA;  }&#xA;&#xA;  var g = gen();&#xA;  console.log(g.next().value);  // 1&#xA;  console.log(g.send(2).value); // 2, not 1!&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;需要注意的是，这段代码在node v0.11.9下跑不通，因为v8并没有实现&lt;a href=&#34;http://stackoverflow.com/questions/20890031/restarting-a-generator-in-javascript&#34;&gt;send方法&lt;/a&gt;，但是通过调用&lt;code&gt;next&lt;/code&gt;方法可以实现一样的效果&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  // node 下可以用`next`方法代替`send`&#xA;&#xA;  function *gen() {&#xA;    var x = yield 1;&#xA;    yield x;&#xA;  }&#xA;&#xA;  var g = gen();&#xA;  console.log(g.next().value);  // 1&#xA;  console.log(g.next(2).value); // 2, not 1!&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;.throw()&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;throw&lt;/code&gt;方法其实和我们熟知的javascript异常抛错是一样的。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;  function *gen() {}&#xA;&#xA;  try {&#xA;    var g = gen();&#xA;    g.throw(&#39;I got you!&#39;);&#xA;  } catch(e) {&#xA;    console.log(e);  // I got you!&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;.close()&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;close&lt;/code&gt;方法在node下也没有实现，并且没有替代的方案。&#xA;根据&lt;a href=&#34;http://wiki.ecmascript.org/doku.php?id=harmony:generators&#34;&gt;规范&lt;/a&gt;的描述，调用&lt;code&gt;close&lt;/code&gt;方法可以直接以当前的&lt;code&gt;value&lt;/code&gt;作为&lt;code&gt;Generator&lt;/code&gt;的返回值。&#xA;虽然容易理解，但是没有看到相关的范例，所以就给出示例代码了。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;代理的玩法(delegating yield)&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;通过前面的一些例子，我们已经知道，调用&lt;code&gt;next&lt;/code&gt;方法就可以得到相应的值，而这个相应的值就是&lt;code&gt;yield&lt;/code&gt;后面的常量或表达式的值。&#xA;如果&lt;code&gt;yield&lt;/code&gt;后面跟着的是一个&lt;code&gt;Generator Object&lt;/code&gt;呢？&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  function *gen() {&#xA;    yield 1;&#xA;    yield 2;&#xA;    yield* gen2();&#xA;  }&#xA;&#xA;  function *gen2() {&#xA;    yield 3;&#xA;    yield 4;&#xA;  }&#xA;&#xA;  var g = gen();&#xA;  console.log(g.next()); // { value: 1, done: false }&#xA;  console.log(g.next()); // { value: 2, done: false }&#xA;  console.log(g.next()); // { value: 3, done: false }&#xA;  console.log(g.next()); // { value: 4, done: false }&#xA;  console.log(g.next()); // { value: undefined, done: true }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;到现在，我们还是第一次碰到&lt;code&gt;yield*&lt;/code&gt;。那么之前的问题的表述就有了问题，应该是&lt;code&gt;yield*&lt;/code&gt;后面跟着一个&lt;code&gt;Generator Object&lt;/code&gt;。&#xA;从代码里不难看出，&lt;code&gt;g.next&lt;/code&gt;的返回值会被代理到&lt;code&gt;gen2().next&lt;/code&gt;，直到&lt;code&gt;gen2&lt;/code&gt;的迭代结束。这个特性和函数的嵌套调用很像，但&lt;code&gt;Generator&lt;/code&gt;本身也是函数，不是吗？&#xA;真是“熟悉的陌生人”。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;node下怎么玩？&lt;/h4&gt;&#xA;&#xA;&lt;h4&gt;走正门&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;要使用&lt;code&gt;Generator&lt;/code&gt;特性，需要：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、Node版本&amp;gt;=0.11.9&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2、启用&lt;code&gt;harmony&lt;/code&gt;选项：&lt;code&gt;node --harmony&lt;/code&gt; or &lt;code&gt;node --harmony_generators&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;走偏门&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;如果你的node环境不满足“走正门”的条件，可以使用&lt;code&gt;gnode&lt;/code&gt;模块：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;1、在你的项目中&lt;code&gt;npm install gnode&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2、在入口文件（例如：&lt;code&gt;index.js&lt;/code&gt;）添加如下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;javascript&#34;&gt;  // require hack&#xA;  require(&#39;gnode&#39;);&#xA;  &#xA;  // go on&#xA;  require(&#39;lib/app.js&#39;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;em&gt;注意：入口文件不应包含&lt;code&gt;Generator&lt;/code&gt;的相关定义，否则在预解析阶段就会报错，把代码逻辑移到另外的文件（例如：app.js）中&lt;/em&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;To be continued&amp;hellip;&lt;/h3&gt;&#xA;</description>
    </item>
    <item>
      <title>树莓派上搭建blog</title>
      <link>http://luckydrq.com/2014-06-02/pi-blog</link>
      <pubDate>2014-06-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在PI上搭建blog是非常平常且让那些极客们嗤之以鼻的事情，而且网上已经有不少这样的文章，比如&lt;a href=&#34;http://defworld.com/2013-05/build-your-blog-with-gor-and-pi.html&#34;&gt;我同事的这篇文章&lt;/a&gt;，里面还引用了许多先人们的文章。那为啥我还要写这么一篇文章？好吧，首先我不是极客，可以没有极客的节操。其次时代在进步，有些先人们遇到的坑已被填平，而新的坑又在等着我。最后是给自己的一个交代，好歹也折腾了好几天。。。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我是个懒人，因此搭建博客也是按照先人们的方案来搞得（基于&lt;code&gt;GOR&lt;/code&gt;搭建）。当初就是看上了它应用的&lt;code&gt;bootstrap&lt;/code&gt;的界面风格，很简洁。不废话，下面我就直接进行总结：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Go安装&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;直接用官网&lt;code&gt;go1.2.2.linux-386.tar.gz&lt;/code&gt;这个版本的包就行了，编译、测试都能通过（时间有点长）。不需要按先人们所说的用什么&lt;code&gt;TIP&lt;/code&gt;分支的代码。另外，不要在PI上直接下载tar包，那样会很慢。先下载到自己的机器再&lt;code&gt;scp&lt;/code&gt;到PI上。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;SSL故障&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;不知道是个例还是所有这个批次的Respbian都有这个问题(我的内核版本是3.12.19+)，在进行https连接时报CA证书校验失败，导致直接https用不了。网上找了一堆解决方案都不行。于是，直接重新安装了&lt;code&gt;openssl&lt;/code&gt;，得以解决。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;DDNS&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在给PI设置固定的局域网IP，并给路由器设置了端口转发规则之后，接下来要搞定的就是动态DNS的问题，因为路由器的公网IP是会变化的，这样在域名解析的时候也需要动态更新IP。一开始，我用的是同事文章里的这段&lt;code&gt;python&lt;/code&gt;&lt;a href=&#34;https://gist.github.com/chuangbo/833369&#34;&gt;脚本&lt;/a&gt;，但是不知道为什么，当路由器IP变化的时候，dnspod上还是没有更新过来，导致博客直接就挂掉了。就这样过了两三周一直拖着没做，今天有空就用nodejs根据dnspod提供的开放api写了一个简单的更新A记录的客户端（其实之前已经有人实现了一个比较完备的，但在PI上却跑不起来，node环境v0.10.28），其实就是一个命令，具体用法看&lt;a href=&#34;https://github.com/luckydrq/dnspod-ddns2&#34;&gt;这里&lt;/a&gt;，就不多说了。把这行命令粘贴到&lt;code&gt;/etc/rc.local&lt;/code&gt;里，可以实现开机自启动。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大概就这么多，欢迎交流。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>响应式设计小结</title>
      <link>http://luckydrq.com/2013-09-09/responsive-web-design</link>
      <pubDate>2013-09-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;上周项目不是很忙，就从同事那里借了一本《响应式Web设计实践》，读后收获不小。原本以为响应式就是利用媒介查询(Media Queries)针对不同尺寸的屏幕进行样式定制，现在看来远没有那么简单，需要考虑有很多（技术、设计、流程、项目管理）。下面就对这次学习做个小结。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;注：本书的部分文字和示例参考自《响应式Web设计实践》一书。&lt;/h4&gt;&#xA;&#xA;&lt;h3&gt;1、页面布局&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;先抛开响应式的概念，来聊聊web页面的布局。根据比较权威的分类，布局可以分为4种类型：固定布局、流体布局、弹性布局、混合布局。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;固定布局&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;在固定布局中，页面宽度会被指定为特定大小的像素。它是web设计中最常见的布局，所有的容器、元素几乎都被设定为固定的像素值。一旦确定了，整个站点的宽度及尺寸就确定了，也就是开发者帮用户做了决定。随着使用不同屏幕尺寸的终端来访问站点的用户越来越多，固定布局的弊端也愈加显现：出现滚动条。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;流体布局&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;在流动布局中，度量的单位不再是像素，而是变成了百分比，这样可使页面具有可变的特性。站点可以根据浏览器的宽度自动调节自身宽度。但是，单独使用流动布局不足以在各个尺寸的终端上保持良好的效果。比如，有些文本的行宽在大屏幕上看起来会太宽，而在小屏幕上又看起来太窄。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;弹性布局&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;弹性布局与流动布局类似，只是它们的度量单位不同，通常情况下它以&lt;code&gt;em&lt;/code&gt;作为单位。弹性布局为设计师在排版方面提供了强大的控制权，随着用户增大或缩小字体，元素的宽度也会等比例地变化。但是，在弹性布局中也可能出现令人讨厌的水平滚动条。如果你把字体大小设置为16px，并把容器宽度设置为55em，那么就会在任何宽度小于880px（16x55）的屏幕中出现水平滚动条。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;混合布局&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;混合布局是结合上面两种或两种以上的布局方式。例如，页面上需要有一个300px定宽的广告区域，而其余的列的宽度我们设置为百分比，这样就可以同时达到我们的要求。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那么，哪种布局最具响应性？这取决于你的项目，因为每一种方法都有其优势和不足。大多数情况下，最佳答案是更具灵活性的那几种布局——流动布局、弹性布局或者混合布局。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2、字体大小&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;web上设置字体的大小，不外乎三种：像素（&lt;code&gt;px&lt;/code&gt;）、&lt;code&gt;em&lt;/code&gt;、百分比。像素就不说了。&lt;code&gt;em&lt;/code&gt;是级联的，是以父元素的字体大小为基准进行设定的。这样有好处也有坏处。好处是，当需要调整页面的字体大小时，只需要改变根元素的字体大小，其余元素的字体就会自动进行调整。坏处时，当页面结构发生改变时，需要重新调整字体大小，如果页面变化很大，调整的工作量也会越大。百分比和&lt;code&gt;em&lt;/code&gt;是一样的，以百分比为单位的字体也是级联的，因此理论上来讲，它和&lt;code&gt;em&lt;/code&gt;没有太大的区别。另外一种极具潜力并兼具灵活性的单位是&lt;code&gt;rem&lt;/code&gt;，它与&lt;code&gt;em&lt;/code&gt;的区别在于：&lt;code&gt;rem&lt;/code&gt;的大小只与根元素——Html元素——有关。不过它不兼容某些版本的浏览器（IE6、7、8等），关于&lt;code&gt;rem&lt;/code&gt;可以参考&lt;a href=&#34;http://ued.taobao.com/blog/2013/05/rem-font-size/&#34; target=&#34;_blank&#34;&gt;这篇文章&lt;/a&gt;，由于篇幅问题就不展开讨论了，我是挺看好它的并且已经有同事在项目里使用了。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;3、媒介查询&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;媒介查询可以让你在特定环境下查询到各种属性值——分辨率、色彩深度、高度和宽度等，从而决定应用什么样式。它是响应式设计里不可或缺的技术。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;设备像素与css像素&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;这两个概念在我的&lt;a href=&#34;http://luckydrq.com/#/2013/09/06/A-pixel-is-not-a-pixel.html&#34; target=&#34;_blank&#34;&gt;另一篇译文&lt;/a&gt;里阐述了，它对理解视口至关重要。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;视口&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;在桌面浏览器中，视口是个很简单的概念，即浏览器的可视区域，也指浏览器的宽度。而在移动浏览器中，有两种视口需要考虑：布局视口和视觉视口。根据我的理解，布局视口就是浏览器为页面指定的宽度，而视觉视口是指在设备屏幕能显示下的页面宽度。布局视口的值是不会变的（在iphone里是980px），与缩放是无关的。而视觉视口是会变化的，页面被放大时它就变小了（css像素变大），而页面被缩小时它就变大了，结合上面那篇关于设备像素与css像素的译文理解。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;视口标签&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;在&amp;lt;head&amp;gt;里加上&amp;lt;meta name=&amp;ldquo;viewport&amp;rdquo; content=&amp;ldquo;xx=xxx&amp;rdquo; &amp;gt;元标签可以对视口进行设置。通常的做法是&lt;code&gt;content=&amp;quot;width=device-width&amp;quot;&lt;/code&gt;，即将布局视口设置为设备宽度，这样页面不会被过分地缩放，使内容可以合适地显示在屏幕上。另外，user-scalable属性规定了是否允许用户缩放，书中认为这需要根据具体需求确定。在iOS设备里存在1个bug，如果把视口设置为任意大小并允许缩放，那么横屏之后页面会自动变大。禁用缩放，该问题则不会存在。个人认为，如果响应式做得足够周到，缩放就变得不是很必要，所以我倾向于禁用缩放。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;媒介查询顺序&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;关于媒介查询的结构及用法，网上或书上很容易找到，在此略过。来看看媒介查询的顺序对我们的设计有怎样的影响。你在创建css时，需要选择哪种设计思想来建立响应式站点：是要从桌面端开始向下设计，还是从移动端开始向上设计。从桌面端向下设计，这种思想创建出的样式表通常会是这样的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/* base styles */&#xA;@media all and (max-width:768px) {&#xA;  ...&#xA;}&#xA;@media all and (max-width: 320px){&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这造成了一些问题：虽然目前移动设备对媒介查询的支持有所改善，但仍旧不够完善。在那些不支持媒介查询的移动浏览器上，这些页面就会很不友好甚至浏览体验很差。&#xA;如果反过来，优先建立移动体验，然后针对大屏幕使用媒介查询对布局作出调整，那就可以在很大程度上规避上面所遇到的问题。一个采用从移动端向上的设计思想创建的样式表通常是这样的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/* base styles,for the small-screen experience,go here */&#xA;@media all and (max-width:320px) {&#xA;  ...&#xA;}&#xA;@media all and (max-width: 768px){&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;能获得浏览器更好的支持并不是从移动端向上设计的唯一好处，优先创建移动体验还可以降低css文件的复杂性。例如，从桌面端向下设计需要以下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;aside{&#xA;  display: table-cell;&#xA;  width: 300px;&#xA;}&#xA;@media all and (max-width: 320px){&#xA;  aside{&#xA;    display: block;&#xA;    width: 100%;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;而如果采用从移动端向上设计，样式表则会这样：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;@media all and (min-width: 320px){&#xA;  aside{&#xA;    display: table-cell;&#xA;    width: 300px;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;确定断点&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;根据内容来决定应该在哪里设置断点以及需要设置多少断点才是更好的方法。之后你可以再通过缩放浏览器窗口来查看还有哪里有进一步改善的空间。为了能够确定断点，你可以将浏览器窗口缩放至300px左右（假设你的浏览器允许你缩放到这种程度），然后缓慢地拉宽窗口直到有些东西看起来需要进行一点润色。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;响应式多媒体&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;性能在很多项目中扮演着重要的角色。如果在一个有350px宽的图片就足矣的设备上，却下载了一张624px宽的图片，无疑会严重降低页面的性能，这是个大问题。如果你说，ok，那在小屏幕就不显示图片了。于是，你通过媒介查询在小屏幕上设置图片&lt;code&gt;display:none&lt;/code&gt;，问题还是一样存在。虽然在小屏幕设备上不会显示图片，但是浏览器仍然会去下载它。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;响应式图片策略&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;1、通过脚本判断&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们把页面上的img标签全部删除，然后通过使用html5的&lt;code&gt;data-&lt;/code&gt;属性设置图片的src，例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;ul class=&amp;quot;slats&amp;quot;&amp;gt;&#xA;  &amp;lt;li data-src=&amp;quot;images/ball.jpg&amp;quot; class=&amp;quot;group&amp;quot;&amp;gt;&#xA;    &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;lt;h3&amp;gt;Display image here&amp;lt;/h3&amp;gt;&amp;lt;/a&amp;gt;&#xA;  &amp;lt;/li&amp;gt;&#xA;&amp;lt;/ul&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后，你的javascript脚本可以这样写：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var lazy = document.querySelectorAll(&#39;[data-src]&#39;)&#xA;for (var i = 0; i &amp;lt; lazy.length; i++){&#xA;  var source = lazy[i].getAttribute(&#39;data-src&#39;)&#xA;  var img = new Image()&#xA;  img.src = source&#xA;  lazy[i].insertBefore(img, lazy[i].firstChild)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以上通过javascript实现了图片的懒加载，但是还没有加入屏幕尺寸的判断逻辑，我们可以使用&lt;code&gt;matchMedia&lt;/code&gt;方法来实现。&lt;code&gt;matchMedia&lt;/code&gt;是javascript内部自带的方法，你可以将css媒介查询作为参数传递给它，它会返回相关媒介查询是否匹配的信息。具体来说，函数会返回一个MediaQueryList对象，该对象具有两个属性：&lt;code&gt;matches&lt;/code&gt;和&lt;code&gt;media&lt;/code&gt;。&lt;code&gt;matches&lt;/code&gt;属性的值可以是true（如果媒介查询匹配）或者false（不匹配）。&lt;code&gt;media&lt;/code&gt;属性的值就是你刚刚传递的参数，例如对于&lt;code&gt;window.matchMedia(&amp;quot;(min-width:200px)&amp;quot;)&lt;/code&gt;来说media属性将会返回&amp;rdquo;(min-width:200px)&amp;ldquo;。目前支持&lt;code&gt;matchMedia()&lt;/code&gt;方法的浏览器有： Chrome、Safari 5.1+、Firefox 9、Android 3+以及iOS5+。不过，Paul Irish为那些不支持该方法的浏览器创建了一个方便使用的polyfill。具体的代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if (window.matchMedia(&amp;quot;(min-width: 37.5em)&amp;quot;).matches) {&#xA;  //load in the images&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2、找服务器帮忙&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用服务器检测技术来决定应该下载哪一张图片。目前一淘的响应式图片就是采用这种策略。但是，这种服务器端处理对未来也不是特别友好。随着请求你站点内容的设备的种类不断增长，维护所有设备的信息会变得越来越困难。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3、Sencha.io Src&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Sencha.io Src&lt;/code&gt;是最近似于即插即用型的响应式图片解决方案。要使用该服务，你只需在你的图片资源前面加上&lt;code&gt;Sencha.io Src&lt;/code&gt;的链接即可：&lt;code&gt;http://src.sencha.io/http://mysite.com/images/ball.jpg&lt;/code&gt;。&lt;code&gt;Sencha.io Src&lt;/code&gt;会使用发起请求的设备的用户代理字符串来计算出设备屏幕的大小，然后根据该数值来缩放图片。而且，它也足够聪明，会缓存请求以便提高重复请求的效率。但是，如果你除了缩放图片，还想对图片进行重新裁剪，这就会有一些限制。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4、自适应图片&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另一个近乎于即插即用的解决方案是由&lt;code&gt;Matt Wilcox&lt;/code&gt;创建的自适应图片，它会先确定屏幕的大小，然后创建并缓存一张缩放后的图片。该方案是在服务器端维护一份断点配置。你需要在页面文档头部上加入以下一段代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;document.cookie = &#39;resolution=&#39; + Math.max(screen.width, screen.height) + &#39;;path=/&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这行代码会获取屏幕的分辨率，并保存到cookie中。服务器获取到屏幕分辨率后，与配置进行对比，选出最合适的图片尺寸然后输出。图片创建过程是动态的，并辅以缓存以提高响应效率。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;高分辨率屏幕&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;随着iPhone、iPad和MacBook Pro都采用了Retina屏幕（像素密度高达326ppi），意味着图片的显示效果将会异常的细致而清晰——如果图片为此做了优化。如果图片没有做优化，那么他们的显示效果将会是颗粒状并且是模糊的。为高分辨率屏幕创建图片就意味着要创建面积较大的图片，同时也就意味着图片的文件大小也会很大。为此，你可以为非Webkit浏览器使用&lt;code&gt;min-resolution&lt;/code&gt;媒介查询，对于基于Webkit的浏览器，你必须使用&lt;code&gt;-webkit-min-device-pixel-ratio&lt;/code&gt;媒介查询。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;SVG&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;对于高分辨率屏幕上的显示问题，以及图片在不同尺寸屏幕上显示时的可伸缩问题，可以将可伸缩矢量图形（SVG）作为一个解决方案。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;其他&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;视频与广告也是人们关心的重点。对于视频来说，使用固定比例的方法可以让你根据屏幕尺寸适当地缩放视频。与往常一样，要有意识地关注性能。最好能够为小屏幕用户显示视频链接，而为大屏幕用户直接显示嵌入的视频。对于广告来说，解决技术上的挑战并不困难。如果你是从自己系统中加载广告的，javascript或者一些响应式的html和css都可以为不同分辨率的屏幕上为改变广告提供帮助。更大的问题是如何把销售团队和第三方广告网络也拉上船。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;RESS&lt;/h3&gt;&#xA;&#xA;&lt;h4&gt;两种基本检测方法&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;1、用户代理检测&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用户代理检测是通过检测浏览器的用户代理字符串（User Agent）来决定为设备提供哪种站点的方法，这一过程是在服务端完成的。用户代理的名声并不好，在很长一段时间内它都被人们误用或者滥用。那些没有受到青睐的浏览器可以“撒谎”，把它们自己的用户代理字符串修改为那些更受欢迎的浏览器的样子。目前，一淘的仍然使用基于用户代理的检测。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2、功能检测&lt;/p&gt;&#xA;&#xA;&lt;p&gt;很多脚本都有功能检测的功能，其中最为著名的就是Modernizr。它可以测试超过40种不同的功能，而且还能提供另外3样有助于开发的东西：1、一个包含测试结果的javascript对象。2、会在html元素中增加类名，以表明对于功能的支持情况。3、提供一个脚本加载器，可以有条件地加载polyfill。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;刚才说的&lt;code&gt;Modernizr&lt;/code&gt;是在客户端进行检测，还有一个叫&lt;code&gt;modernizr-server&lt;/code&gt;的代码库，可以在服务器端获取&lt;code&gt;Modernizr&lt;/code&gt;检测结果，从而可以在页面被下载之前改变代码结构。使用时需要下载&lt;code&gt;modernizr-server&lt;/code&gt;和最新的javascript库，并将下载好的javascript库命名为&lt;code&gt;modernizr.js&lt;/code&gt;，然后放入&lt;code&gt;modernizr-server/modernizr.js/&lt;/code&gt;文件夹下。原理是：当访问者第一次访问某一页面时会执行javascript的代码库并获取测试的结果。然后这些结果被添加到cookie中，而页面则会立刻重新加载。当下一次加载页面时，代码库会读取cookie中的信息，并且如果可以的话会将其置于会话变量中传回服务器。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;将用户代理检测和功能检测相结合，将服务器端检测和响应式设计相结合，被称为RESS。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;计划、设计流程&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;毫无疑问，响应式设计是一种强大的技术，但它不是银弹。最大化你站点的价值需要花费大量的时间并作出谨慎的决定。你必须将响应式设计整合到项目的计划中去。研究你的分析数据，但是要记住它们也会说谎。仔细考虑一下你的内容，虽然不需要在设计和开发前就把内容最终确定下来，但是你至少应该知道内容的结构。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;响应式设计远远不只是一种简单的策略，它为Web项目带来的是一整套全新的、完整的方法，也是一种新的、可以更好地利用这一平台的工作流程。新流程必须是敏捷而灵活的。要去拥抱Web的交互本性，并开始在浏览器中创建模型。平面图片只能描绘出站点有限的一部分，它们没有能力描绘出用户与网站交互时设计看起来会是什么样子，而且还使得交付变得复杂。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>译:此像素非彼像素</title>
      <link>http://luckydrq.com/2013-09-06/a-pixel-is-not-a-pixel</link>
      <pubDate>2013-09-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;译者：这是篇关于&lt;code&gt;css像素&lt;/code&gt;和&lt;code&gt;设备像素&lt;/code&gt;的老文章，但我最近才有幸拜读，不得不感叹下自己学艺不精。之前做响应式设计，也没有搞清楚两者之间的关系，直到看了&lt;a href=&#34;http://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html&#34; title=&#34;原文地址&#34; target=&#34;_blank&#34;&gt;这篇文章&lt;/a&gt;才逐步理清头绪，现在翻译出来做为学习笔记。如果有翻译得不对的地方或者某处翻译你觉得不爽有更好的建议，请给我留言。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;此像素非彼像素&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;昨天John Gruber在他的文章中提到即将发布的新一代iphone升级了分辨率（达到960x640，而现有的只有480x320），并表达了对此次升级的疑惑。同时，他还想知道这会对web开发者们造成怎样的影响。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;目前，我正在深入研究“移动电话宽度与高度的跨浏览器表现”，并且有充分理由得出这样的结论，99%的情况下这不会对web开发者造成任何影响。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;剩下的1%是非常棘手的，但我希望apple能够通过插入一个像素中间层来解决这个问题。(John指出这样的中间层在Android设备上已经存在了。)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在我们开始（讨论）之前，先说明一下：我基本上忽略了设备屏幕尺寸，因为它们对web开发者来说是不重要的。而且，我也不想讨论显示细节、像素密度以及其他一些复杂概念。因此，可能我在措辞中使用了错误的术语，在这里提前说声抱歉。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Web开发者需要什么？&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;当然，我知道web开发者对什么感兴趣。他们需要：css像素，也就是css里声明的像素，比如&lt;code&gt;width:300px&lt;/code&gt;或者&lt;code&gt;font-size:14px&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这些像素与设备的像素密度无关，甚至与传说中即将来临的中间层也是无关的。它们本质上是专门为我们web开发者创造的抽象概念。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个是很容易解释的，我们来考虑一下缩放操作。如果一个用户（把页面）放大了，对于一个设定为&lt;code&gt;width:300px&lt;/code&gt;的元素，会在屏幕上占据越来越大的空间。如果用设备（物理）像素来测量，这个值是越来越大的。但是，在&lt;code&gt;css像素&lt;/code&gt;里，&lt;code&gt;width&lt;/code&gt;仍然是300px，这是通过扩展css像素的宽度来达到放大的效果。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当缩放因子为100%时，1个&lt;code&gt;css像素&lt;/code&gt;的大小与1个&lt;code&gt;设备像素&lt;/code&gt;的大小是相等的（尽管设备的实际像素会被未来的中间层提供的像素所取代）。如下图所示：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/csspixels_100.gif&#34; /&gt;&#xA;这可能看不出什么，因为1个css像素精确地覆盖了1个设备像素。（可能我应该提醒你“缩放100%”在web开发中是没有意义的，缩放等级对我们来说不重要，真正重要的是我们需要知道当前的屏幕能显示多少css像素。）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的两张图片解释了当用户进行缩放时发生了什么。第一张展示了当用户缩小（页面）时，设备像素（深蓝色背景的格子）与css像素（半透明前背景的格子）的情形。css像素变得更小了，1个设备像素可以覆盖多个css像素。第二张图展示了当用户放大（页面）时，设备像素与css像素的情形。现在1个css像素可以覆盖多个设备像素了。&#xA;&lt;div class=&#34;inline-container&#34;&gt;&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/csspixels_out.gif&#34; /&gt;&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/csspixels_in.gif&#34; /&gt;&#xA;&lt;/div&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样我们的&lt;code&gt;width:300px&lt;/code&gt;的元素，宽度永远是300个css像素，而这相当于多少个设备像素就取决于当前的缩放因子了。（在iphone上，你可以通过&lt;code&gt;screen.width&lt;/code&gt;除以&lt;code&gt;window.innerWidth&lt;/code&gt;计算得出缩放因子。这个对于浏览器是普遍不兼容的，除非在不久的将来有一份全面而完备的报告。此外，作为一个web开发者，你不会对影响因子感兴趣，而是屏幕能够显示多少css像素。）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个机制不会变，如果变了，那么所有针对iphone做优化的那些站点，都会瞬间变得非常的不友好，而这是apple不惜一切代价要避免的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，对于一个被全面缩小的网站，它将仍然显示在980 css像素宽度的屏幕里，而这相当于多少设备像素对我们来说就不重要了。（译：如果没有设置intial-scale=1，iphone会对网页进行缩放以至于能够在屏幕里显示整个网页。）&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;两种策略&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;然而，可以有两种策略：&lt;code&gt;device-width&lt;/code&gt;媒介查询和&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; width=&amp;quot;device-width&amp;quot;&amp;gt;&lt;/code&gt;标签(Note：经过译者测试，width写法有所改动，应放在&lt;code&gt;content&lt;/code&gt;属性里定义，如：&lt;code&gt;content=&amp;quot;width=device-width&amp;quot;&lt;/code&gt;)。两种都采用的是设备像素，而非css像素，因为它们报告的是网页的上下文（载体），而不是内在的css属性。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;媒介查询&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;device-width```媒介查询是以设备像素为度量单位来测量设备的宽度。而```width```媒介查询则是以css像素为度量单位测量整个页面的宽度，在iphone上它至少是980px，原因我将在后面解释。&#34;&gt;&amp;lt;img src=&amp;quot;/assets/media/images/2013_09_06/mobile_mediaqueries.jpg&amp;quot; /&amp;gt;&#xA;&#xA;`device-width`是像这样工作的：&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;div.sidebar {&#xA;  width: 300px;&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;@media all and (max-device-width: 320px) {&#xA;  //当设备屏幕的宽度小于320px时，该样式就生效了。&#xA;  div.sidebar {&#xA;    width: 100px;&#xA;  }&#xA;}&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;现在sidebar的宽度是300个css像素单位，当设备的宽度是320px或更小时，它（sidebar）的宽度就会变成100个css像素单位。（能跟得上吗？这的确有些复杂）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;顺便说一下，理论上你可以以厘米或者英寸为单位做媒介查询（&lt;code&gt;@media all and (max-device-width: 9cm)&lt;/code&gt;）。不幸的是，它看起来并没有被很好地支持，甚至是iphone。这里的问题是，像英寸这样的物理单位经常会被转换成（css）像素。至今我测试过的所有浏览器上，&lt;code&gt;width: 1in&lt;/code&gt;等同于96像素（这实在是太少了）。所以，这些（以英寸等为单位的）媒介查询是不可靠的。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;&lt;code&gt;meta&lt;/code&gt;标签&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;一般来说，&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; width=&amp;quot;device-width&amp;quot;&amp;gt;&lt;/code&gt;甚至更有用。这个标签，最初是由apple创造的，但同时也被许多移动浏览器支持，实际上是用布局视口（layout viewport）来精确地适配设备屏幕。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那么，什么是布局视口呢？它是一个区域（css像素），是浏览器通过计算那些宽度被设置成百分比的元素的尺寸而得出的，比如&lt;code&gt;div.sidebar {width: 20%}&lt;/code&gt;。它通常比设备屏幕的宽度要大得多：iphone上是980px，Opera上是850px，Android上是800px，等等。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/mobile_layoutviewport.jpg&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你加上&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; width=&amp;quot;device-width&amp;quot;&amp;gt;&lt;/code&gt;，布局视口的宽度就被限制为设备宽度（设备像素）。在iphone上，这个值是320px。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你的页面足够窄，窄到当前的屏幕能够显示下，那问题就比较要紧了。去掉页面上任何的css声明以及meta标签。可以发现，它横跨了整个布局视口的可用宽度。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/mq_none.jpg&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这恐怕不是你想要的。你想要文本在屏幕上合适地展现。这就是&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; width=&amp;quot;device-width&amp;quot;&amp;gt;&lt;/code&gt;的任务。当你（在页面上）添加它，整个布局视口就会被限制（iphone上是320px），并且文本也可以合适地展示了。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/mq_yes.jpg&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Apple的改变&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;现在，apple的分辨率变化会给&lt;code&gt;device-width&lt;/code&gt;媒介查询和&lt;code&gt;meta&lt;/code&gt;标签带来怎样的影响呢？当然我不能肯定，但我希望对于web开发者来说没有任何变化。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;meta标签&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;meta&lt;/code&gt;标签是最容易解释的。apple刻意发明了它，为的是让页面内容能够很好地显示在iphone上，并且和广大开发者们一起推动它的发展。这意味着，要改变从&lt;code&gt;meta&lt;/code&gt;标签读取的设备宽度的大小，是十分困难的并且代价也是承受不起的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;事实上，Nexus One已经为apple开辟了一条可以遵循的先河。它的官方设备尺寸是480px（竖屏模式下）。但是，当你应用了&lt;code&gt;meta&lt;/code&gt;标签后，它的屏幕尺寸似乎就变成了320px，官方尺寸的2/3。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果我的理解没有错，这就是John Gruber在谈论Nexus的显示时所说的“丢弃了亚像素(sub-pixel)”，从而导致总共减少了1/3的像素。这使得Nexus精确地适配了&lt;code&gt;meta&lt;/code&gt;标签（Note: 480 * &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; = 320）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，基本上，Google已经插入了一个叫做&lt;code&gt;dips&lt;/code&gt;的中间层，从而做到了设备尺寸独立。它介于web开发者使用的css像素宽度与官方设备尺寸之间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我希望新一代iphone能够应用Nexus的这种技术，即当应用&lt;code&gt;meta&lt;/code&gt;标签查询设备尺寸时报告的是320px（也就是正式分辨率的一半），它之所以是一半而不是2/3，是因为新一代iphone的像素密度要高于Nexus(或其他的一些原因)。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;媒介查询&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;现在，&lt;code&gt;device-width&lt;/code&gt;媒介查询成了唯一的问题。在Nexus上，它（仍然）以480px作为设备尺寸，尽管事实上（前面已经提到），320px是更合适的结果。我们将看看apple会如何处理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最根本的问题是dips是否也会被用作媒介查询。总体来说，我想说我们很希望这样。正式的设备尺寸对web开发者来说不重要：我们想知道有多少内容能显示在屏幕上，而且目前看来dips是最合适的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不幸的是，Nexus目前也没有实现（dips用于媒介查询），就媒介查询来说，&lt;code&gt;device-width&lt;/code&gt;仍然是480px而不是320px。但是，也许apple能够为广大web开发者解决这个问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，对于普通站点以及那些应用meta标签的站点而言，解决方案已经非常明了了。而对于那些需要用到媒介查询的站点，似乎还不够明了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;敬请关注吧。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>自己动手清洗节气门</title>
      <link>http://luckydrq.com/2013-09-01/car-throttle-clean</link>
      <pubDate>2013-09-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;之前在&lt;a href=&#34;http://www.autohome.com.cn&#34; target=&#34;_blank&#34;&gt;汽车之家&lt;/a&gt;上看了一篇关于清洗节气门的&lt;a href=&#34;http://www.autohome.com.cn/use/201307/571332.html&#34; target=&#34;_blank&#34;&gt;文章&lt;/a&gt;。感觉也挺简单的，于是周末自己也清洗了一把。废话不多说，直接上图：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;淘宝上搜“节气门清洗剂”，有很多产品，价格在10来块到几十块不等。我用的这瓶3M的只要10来块，效果还行吧，没用过好的。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/17.jpg&#34; /&gt;&#xA;工具箱一个，修车必备：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/15.jpg&#34; /&gt;&#xA;开了近3W5公里，发动机舱已经很脏了，接下来会搞一次发动机舱清洗。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/1.jpg&#34; /&gt;&#xA;这是我们今天动手术的主要部位：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/3.jpg&#34; /&gt;&#xA;看到了吧，连接进气软管的铝制件就是节气门：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/4.jpg&#34; /&gt;&#xA;先拆除进气软管才能看到节气门。进气软管由铝圈套住，先把它解下来：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/5.jpg&#34; /&gt;&#xA;就是这个：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/6.jpg&#34; /&gt;&#xA;拆除软管后，节气门就看到了：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/7.jpg&#34; /&gt;&#xA;节气门的正面是比较干净的，反面就全是积碳了。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/8.jpg&#34; /&gt;&#xA;这时把给车通上电（注意：只是通电不要着车），踩下油门踏板，节气门中间的金属片就会张开角度，ECU就是根据油门深度来判断节气门的开合角度，从而精确控制喷油量的（现在绝大多数车都是电子油门，拉线油门是纯机械控制的）。可以看到里面黑乎乎的很脏：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/9.jpg&#34; /&gt;&#xA;由于科鲁兹的节气门与诸多管线相连，整个拆除比较麻烦，因此我选择直接用布擦洗（效果还是不错的）。把清洗剂喷在抹布上，用手掰开节气门中央的金属片进行擦洗：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/10.jpg&#34; /&gt;&#xA;经过反复清洗，周边的一些黑东东似乎擦不掉。。。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/12.jpg&#34; /&gt;&#xA;最后，按照原先的拆除步骤，反过来操作复原。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/14.jpg&#34; /&gt;&#xA;收工了，身上各种脏啊：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/16.jpg&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;总结一下，整个操作的过程中还是比较顺利的。有几点需要注意下：1、整个操作过程中需要带手套，以免粘上清洗剂（强腐蚀性）。2、在清洗节气门的时候，不要直接将清洗剂喷入节气门，那样会流到气缸里，损伤发动机。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这次清洗并没有拆除整个节气门（对其他管路暂时还不熟，以后再介绍整个拆除的工序），担心效果不明显，不过晚上着车后发现怠速转速下降了，低扭说不上明显好转但能感觉到起步更轻盈了。清理积碳使得整个进气更加顺畅了，洗洗更健康啊。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>git hook在项目里的简单应用</title>
      <link>http://luckydrq.com/2013-08-10/git-hook</link>
      <pubDate>2013-08-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;上一篇关于&lt;code&gt;git&lt;/code&gt;的博文扯到了&lt;code&gt;git hook&lt;/code&gt;，一直想用它搞点实用的事情出来，正好最近的项目处于预发布之前的最后测试阶段，页面上的css文件地址换成了cdn地址，这样带来的麻烦就是如果css要修改，必须要重新发布到cdn上。为了偷懒，就想每次git commit成功后执行hook脚本自动完成发布cdn的事情。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于&lt;code&gt;git hook&lt;/code&gt;，网上有一大堆介绍，可以看看&lt;a href=&#34;http://blog.jobbole.com/26131/&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;。总得说来，&lt;code&gt;git hook&lt;/code&gt;可以分为客户端&lt;code&gt;hook&lt;/code&gt;和服务器端&lt;code&gt;hook&lt;/code&gt;。客户端&lt;code&gt;hook&lt;/code&gt;用于客户端的操作，如提交和合并。服务器端&lt;code&gt;hook&lt;/code&gt;用于git服务器端的操作，如接收被推送的提交。在&lt;code&gt;git&lt;/code&gt;操作周期的不同阶段，会触发相应的&lt;code&gt;hook&lt;/code&gt;（如果你写了）。所有的这些脚本，都存放在你的工程的&lt;code&gt;Git&lt;/code&gt;目录下，具体路径为&lt;code&gt;.git/hooks/&lt;/code&gt;。执行&lt;code&gt;ls .git/hooks&lt;/code&gt;查看一下，会发现有很多以&lt;code&gt;.sample&lt;/code&gt;结尾的文件，再看看这些文件内容，全都是shell脚本。这些文件是&lt;code&gt;git&lt;/code&gt;为你预置的一些&lt;code&gt;hook&lt;/code&gt;脚本，只要把文件的后缀名&lt;code&gt;.sample&lt;/code&gt;去掉，脚本就生效了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里面的大多数&lt;code&gt;hook&lt;/code&gt;我都没有用过，就只说说项目里的用法。经过尝试，最终选用了&lt;code&gt;commit-msg&lt;/code&gt;和&lt;code&gt;post-commit&lt;/code&gt;这两个客户端&lt;code&gt;hook&lt;/code&gt;。这里可能有人要问，不就是发个cdn么，这么屁大点事还要用两个脚本？对于这里的逻辑，我认为是这样的：1、只有当本次提交涉及修改的文件里包括我想要的css文件时，才能发布cdn。2、只有当提交操作完成（即commit成功），再做发布cdn的操作。经过试验发现，在提交操作完成后，找不到合适的办法获取本次提交的修改文件列表，这样就无法知道本次提交是否涉及css文件。这里可能又有人会说，干脆么每次提交都整一次发布好了哇。可以是可以，但是有点不爽啊。。。&lt;code&gt;commit-msg&lt;/code&gt;是在提交之前调用的，如果脚本返回非零的值，那么本次提交将会被取消。&lt;code&gt;post-commit&lt;/code&gt;是在提交之后调用的，如果提交不成功，那么它就不会执行。对于检测是否存在目标的css文件，我用了比较土的办法，在&lt;code&gt;commit-msg&lt;/code&gt;脚本里，检查修改文件里是否存在目标文件，如果存在，就创建一个空文件A。提交完成后，在&lt;code&gt;post-commit&lt;/code&gt;里检查空文件A是否存在，如果存在，就执行发布cdn操作。下面就把代码贴出来：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;commit-msg&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/sh&#xA;files=`git diff --cached --name-only`&#xA;EXTRA_File=&amp;quot;$EXTRA$&amp;quot;&#xA;&#xA;if [ -f $EXTRA_File ]; then&#xA;  rm $EXTRA_File&#xA;fi&#xA;&#xA;for file in $files; do&#xA;  #echo $file&#xA;&#xA;  if [ &amp;quot;$file&amp;quot; == &amp;quot;public/index.css&amp;quot; ]; then&#xA;    touch $EXTRA_File&#xA;    break&#xA;  fi&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;post-commit&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/sh&#xA;EXTRA_File=&amp;quot;$EXTRA$&amp;quot;&#xA;&#xA;if [ -f $EXTRA_File ]; then&#xA;  cd ~/workspace/mosaic-demo/public/mm&#xA;  sh deploy.sh&#xA;  rm $EXTRA_File&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;deploy.sh&lt;/code&gt;封装了css压缩、上传cdn的操作，也就是你想要做的操作，也贴出来走完整个流程。不过主要就是上面的两段脚本，很简单吧！如果有朋友有更好的办法，欢迎拍砖！！！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;deploy.sh&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/sh&#xA;cp ../index.css ./build/index.css&#xA;cd ../../&#xA;grunt&#xA;cd public/mm&#xA;echo &#39;uploading css to cdn...&#39;&#xA;node deploy.js&#xA;echo &#39;uploading success!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>创建基于本地协议的git服务器</title>
      <link>http://luckydrq.com/2013-07-28/git-set-up-local-repository</link>
      <pubDate>2013-07-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天了解了下git挂钩（&lt;code&gt;git hook&lt;/code&gt;），本想通过&lt;code&gt;Github&lt;/code&gt;实践一下其中的服务器挂钩。后来经过Google发现，&lt;code&gt;Github&lt;/code&gt;只提供所谓的&lt;code&gt;web hook&lt;/code&gt;，即当你push代码至某个repository时，&lt;code&gt;Github&lt;/code&gt;服务器会发一个POST请求到你所注册的url，本次push的相关信息会作为一个JSON串随请求一起发过去。这与我的需求不符，我想要git服务器在收到push通知后执行一些操作（本地操作或者网络操作）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;于是，就想自己搭个git代码服务器。架设git服务器共有4种协议：本地协议、SSH协议、git协议、HTTP/S协议。今天就说说最简单的一种：本地协议。通俗地说，git服务器就是一个代码远程仓库。先来看下书上的一段文字：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;远程仓库通常只是一个裸仓库（bare repository）—— 即一个没有当前工作目录的仓库。因为该仓库只是一个合作媒介，所以不需要从硬盘上取出最新版本的快照；仓库里存放的仅仅是 Git 的数据。简单地说，裸仓库就是你工作目录中.git 子目录内的内容。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;以上文字的意思就是，仓库必须是裸的。我们先从创建裸仓库开始：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd ~&#xA;git init --bare gitLocal    //仓库目录：~/gitLocal&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后，我们创建并初始化一个代码目录，比如Test.git&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd gitLocal&#xA;git init --bare Test.git    &#xA;&#xA;//注意，这里我踩过坑，如果不加--bare参数，后续在push时会发生[remote rejected]错误&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码目录创建好后，我们就可以对远程仓库进行拉取和推送数据了。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd ~&#xA;git clone ~/gitLocal/Test.git    //是不是和Github的git地址很像？&#xA;cd Test&#xA;touch 1.js&#xA;git add 1.js&#xA;git commit -m &#39;add a file&#39;&#xA;git push origin master&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样就完成了一次提交。后面的工作就和操作&lt;code&gt;Github&lt;/code&gt;的远程仓库没区别了。&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>