<?xml version="1.0"?>
<rss version="2.0">  <channel>
    <title>Lucky Blog</title>
    <link>http://luckydrq.com</link>
    <pubDate>12 May 14 00:00 CST</pubDate>
    <item>
      <title>响应式设计小结</title>
      <link>http://luckydrq.com/web/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%B0%8F%E7%BB%93/</link>
      <pubDate>2013-09-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;上周项目不是很忙，就从同事那里借了一本《响应式Web设计实践》，读后收获不小。原本以为响应式就是利用媒介查询(Media Queries)针对不同尺寸的屏幕进行样式定制，现在看来远没有那么简单，需要考虑有很多（技术、设计、流程、项目管理）。下面就对这次学习做个小结。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;注：本书的部分文字和示例参考自《响应式Web设计实践》一书。&lt;/h4&gt;&#xA;&#xA;&lt;h3&gt;1、页面布局&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;先抛开响应式的概念，来聊聊web页面的布局。根据比较权威的分类，布局可以分为4种类型：固定布局、流体布局、弹性布局、混合布局。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;固定布局&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;在固定布局中，页面宽度会被指定为特定大小的像素。它是web设计中最常见的布局，所有的容器、元素几乎都被设定为固定的像素值。一旦确定了，整个站点的宽度及尺寸就确定了，也就是开发者帮用户做了决定。随着使用不同屏幕尺寸的终端来访问站点的用户越来越多，固定布局的弊端也愈加显现：出现滚动条。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;流体布局&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;在流动布局中，度量的单位不再是像素，而是变成了百分比，这样可使页面具有可变的特性。站点可以根据浏览器的宽度自动调节自身宽度。但是，单独使用流动布局不足以在各个尺寸的终端上保持良好的效果。比如，有些文本的行宽在大屏幕上看起来会太宽，而在小屏幕上又看起来太窄。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;弹性布局&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;弹性布局与流动布局类似，只是它们的度量单位不同，通常情况下它以&lt;code&gt;em&lt;/code&gt;作为单位。弹性布局为设计师在排版方面提供了强大的控制权，随着用户增大或缩小字体，元素的宽度也会等比例地变化。但是，在弹性布局中也可能出现令人讨厌的水平滚动条。如果你把字体大小设置为16px，并把容器宽度设置为55em，那么就会在任何宽度小于880px（16x55）的屏幕中出现水平滚动条。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;混合布局&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;混合布局是结合上面两种或两种以上的布局方式。例如，页面上需要有一个300px定宽的广告区域，而其余的列的宽度我们设置为百分比，这样就可以同时达到我们的要求。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那么，哪种布局最具响应性？这取决于你的项目，因为每一种方法都有其优势和不足。大多数情况下，最佳答案是更具灵活性的那几种布局——流动布局、弹性布局或者混合布局。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;2、字体大小&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;web上设置字体的大小，不外乎三种：像素（&lt;code&gt;px&lt;/code&gt;）、&lt;code&gt;em&lt;/code&gt;、百分比。像素就不说了。&lt;code&gt;em&lt;/code&gt;是级联的，是以父元素的字体大小为基准进行设定的。这样有好处也有坏处。好处是，当需要调整页面的字体大小时，只需要改变根元素的字体大小，其余元素的字体就会自动进行调整。坏处时，当页面结构发生改变时，需要重新调整字体大小，如果页面变化很大，调整的工作量也会越大。百分比和&lt;code&gt;em&lt;/code&gt;是一样的，以百分比为单位的字体也是级联的，因此理论上来讲，它和&lt;code&gt;em&lt;/code&gt;没有太大的区别。另外一种极具潜力并兼具灵活性的单位是&lt;code&gt;rem&lt;/code&gt;，它与&lt;code&gt;em&lt;/code&gt;的区别在于：&lt;code&gt;rem&lt;/code&gt;的大小只与根元素——Html元素——有关。不过它不兼容某些版本的浏览器（IE6、7、8等），关于&lt;code&gt;rem&lt;/code&gt;可以参考&lt;a href=&#34;http://ued.taobao.com/blog/2013/05/rem-font-size/&#34; target=&#34;_blank&#34;&gt;这篇文章&lt;/a&gt;，由于篇幅问题就不展开讨论了，我是挺看好它的并且已经有同事在项目里使用了。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;3、媒介查询&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;媒介查询可以让你在特定环境下查询到各种属性值——分辨率、色彩深度、高度和宽度等，从而决定应用什么样式。它是响应式设计里不可或缺的技术。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;设备像素与css像素&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;这两个概念在我的&lt;a href=&#34;http://luckydrq.com/#/2013/09/06/A-pixel-is-not-a-pixel.html&#34; target=&#34;_blank&#34;&gt;另一篇译文&lt;/a&gt;里阐述了，它对理解视口至关重要。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;视口&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;在桌面浏览器中，视口是个很简单的概念，即浏览器的可视区域，也指浏览器的宽度。而在移动浏览器中，有两种视口需要考虑：布局视口和视觉视口。根据我的理解，布局视口就是浏览器为页面指定的宽度，而视觉视口是指在设备屏幕能显示下的页面宽度。布局视口的值是不会变的（在iphone里是980px），与缩放是无关的。而视觉视口是会变化的，页面被放大时它就变小了（css像素变大），而页面被缩小时它就变大了，结合上面那篇关于设备像素与css像素的译文理解。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;视口标签&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;在&amp;lt;head&amp;gt;里加上&amp;lt;meta name=&amp;ldquo;viewport&amp;rdquo; content=&amp;ldquo;xx=xxx&amp;rdquo; &amp;gt;元标签可以对视口进行设置。通常的做法是&lt;code&gt;content=&amp;quot;width=device-width&amp;quot;&lt;/code&gt;，即将布局视口设置为设备宽度，这样页面不会被过分地缩放，使内容可以合适地显示在屏幕上。另外，user-scalable属性规定了是否允许用户缩放，书中认为这需要根据具体需求确定。在iOS设备里存在1个bug，如果把视口设置为任意大小并允许缩放，那么横屏之后页面会自动变大。禁用缩放，该问题则不会存在。个人认为，如果响应式做得足够周到，缩放就变得不是很必要，所以我倾向于禁用缩放。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;媒介查询顺序&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;关于媒介查询的结构及用法，网上或书上很容易找到，在此略过。来看看媒介查询的顺序对我们的设计有怎样的影响。你在创建css时，需要选择哪种设计思想来建立响应式站点：是要从桌面端开始向下设计，还是从移动端开始向上设计。从桌面端向下设计，这种思想创建出的样式表通常会是这样的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/* base styles */&#xA;@media all and (max-width:768px) {&#xA;  ...&#xA;}&#xA;@media all and (max-width: 320px){&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这造成了一些问题：虽然目前移动设备对媒介查询的支持有所改善，但仍旧不够完善。在那些不支持媒介查询的移动浏览器上，这些页面就会很不友好甚至浏览体验很差。&#xA;如果反过来，优先建立移动体验，然后针对大屏幕使用媒介查询对布局作出调整，那就可以在很大程度上规避上面所遇到的问题。一个采用从移动端向上的设计思想创建的样式表通常是这样的：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;/* base styles,for the small-screen experience,go here */&#xA;@media all and (max-width:320px) {&#xA;  ...&#xA;}&#xA;@media all and (max-width: 768px){&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;能获得浏览器更好的支持并不是从移动端向上设计的唯一好处，优先创建移动体验还可以降低css文件的复杂性。例如，从桌面端向下设计需要以下代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;aside{&#xA;  display: table-cell;&#xA;  width: 300px;&#xA;}&#xA;@media all and (max-width: 320px){&#xA;  aside{&#xA;    display: block;&#xA;    width: 100%;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;而如果采用从移动端向上设计，样式表则会这样：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;@media all and (min-width: 320px){&#xA;  aside{&#xA;    display: table-cell;&#xA;    width: 300px;&#xA;  }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4&gt;确定断点&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;根据内容来决定应该在哪里设置断点以及需要设置多少断点才是更好的方法。之后你可以再通过缩放浏览器窗口来查看还有哪里有进一步改善的空间。为了能够确定断点，你可以将浏览器窗口缩放至300px左右（假设你的浏览器允许你缩放到这种程度），然后缓慢地拉宽窗口直到有些东西看起来需要进行一点润色。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;响应式多媒体&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;性能在很多项目中扮演着重要的角色。如果在一个有350px宽的图片就足矣的设备上，却下载了一张624px宽的图片，无疑会严重降低页面的性能，这是个大问题。如果你说，ok，那在小屏幕就不显示图片了。于是，你通过媒介查询在小屏幕上设置图片&lt;code&gt;display:none&lt;/code&gt;，问题还是一样存在。虽然在小屏幕设备上不会显示图片，但是浏览器仍然会去下载它。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;响应式图片策略&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;1、通过脚本判断&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我们把页面上的img标签全部删除，然后通过使用html5的&lt;code&gt;data-&lt;/code&gt;属性设置图片的src，例如：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;ul class=&amp;quot;slats&amp;quot;&amp;gt;&#xA;  &amp;lt;li data-src=&amp;quot;images/ball.jpg&amp;quot; class=&amp;quot;group&amp;quot;&amp;gt;&#xA;    &amp;lt;a href=&amp;quot;#&amp;quot;&amp;gt;&amp;lt;h3&amp;gt;Display image here&amp;lt;/h3&amp;gt;&amp;lt;/a&amp;gt;&#xA;  &amp;lt;/li&amp;gt;&#xA;&amp;lt;/ul&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后，你的javascript脚本可以这样写：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;var lazy = document.querySelectorAll(&#39;[data-src]&#39;)&#xA;for (var i = 0; i &amp;lt; lazy.length; i++){&#xA;  var source = lazy[i].getAttribute(&#39;data-src&#39;)&#xA;  var img = new Image()&#xA;  img.src = source&#xA;  lazy[i].insertBefore(img, lazy[i].firstChild)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以上通过javascript实现了图片的懒加载，但是还没有加入屏幕尺寸的判断逻辑，我们可以使用&lt;code&gt;matchMedia&lt;/code&gt;方法来实现。&lt;code&gt;matchMedia&lt;/code&gt;是javascript内部自带的方法，你可以将css媒介查询作为参数传递给它，它会返回相关媒介查询是否匹配的信息。具体来说，函数会返回一个MediaQueryList对象，该对象具有两个属性：&lt;code&gt;matches&lt;/code&gt;和&lt;code&gt;media&lt;/code&gt;。&lt;code&gt;matches&lt;/code&gt;属性的值可以是true（如果媒介查询匹配）或者false（不匹配）。&lt;code&gt;media&lt;/code&gt;属性的值就是你刚刚传递的参数，例如对于&lt;code&gt;window.matchMedia(&amp;quot;(min-width:200px)&amp;quot;)&lt;/code&gt;来说media属性将会返回&amp;rdquo;(min-width:200px)&amp;ldquo;。目前支持&lt;code&gt;matchMedia()&lt;/code&gt;方法的浏览器有： Chrome、Safari 5.1+、Firefox 9、Android 3+以及iOS5+。不过，Paul Irish为那些不支持该方法的浏览器创建了一个方便使用的polyfill。具体的代码如下：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;if (window.matchMedia(&amp;quot;(min-width: 37.5em)&amp;quot;).matches) {&#xA;  //load in the images&#xA;  ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;2、找服务器帮忙&lt;/p&gt;&#xA;&#xA;&lt;p&gt;使用服务器检测技术来决定应该下载哪一张图片。目前一淘的响应式图片就是采用这种策略。但是，这种服务器端处理对未来也不是特别友好。随着请求你站点内容的设备的种类不断增长，维护所有设备的信息会变得越来越困难。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;3、Sencha.io Src&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;Sencha.io Src&lt;/code&gt;是最近似于即插即用型的响应式图片解决方案。要使用该服务，你只需在你的图片资源前面加上&lt;code&gt;Sencha.io Src&lt;/code&gt;的链接即可：&lt;code&gt;http://src.sencha.io/http://mysite.com/images/ball.jpg&lt;/code&gt;。&lt;code&gt;Sencha.io Src&lt;/code&gt;会使用发起请求的设备的用户代理字符串来计算出设备屏幕的大小，然后根据该数值来缩放图片。而且，它也足够聪明，会缓存请求以便提高重复请求的效率。但是，如果你除了缩放图片，还想对图片进行重新裁剪，这就会有一些限制。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;4、自适应图片&lt;/p&gt;&#xA;&#xA;&lt;p&gt;另一个近乎于即插即用的解决方案是由&lt;code&gt;Matt Wilcox&lt;/code&gt;创建的自适应图片，它会先确定屏幕的大小，然后创建并缓存一张缩放后的图片。该方案是在服务器端维护一份断点配置。你需要在页面文档头部上加入以下一段代码：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;document.cookie = &#39;resolution=&#39; + Math.max(screen.width, screen.height) + &#39;;path=/&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这行代码会获取屏幕的分辨率，并保存到cookie中。服务器获取到屏幕分辨率后，与配置进行对比，选出最合适的图片尺寸然后输出。图片创建过程是动态的，并辅以缓存以提高响应效率。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;高分辨率屏幕&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;随着iPhone、iPad和MacBook Pro都采用了Retina屏幕（像素密度高达326ppi），意味着图片的显示效果将会异常的细致而清晰——如果图片为此做了优化。如果图片没有做优化，那么他们的显示效果将会是颗粒状并且是模糊的。为高分辨率屏幕创建图片就意味着要创建面积较大的图片，同时也就意味着图片的文件大小也会很大。为此，你可以为非Webkit浏览器使用&lt;code&gt;min-resolution&lt;/code&gt;媒介查询，对于基于Webkit的浏览器，你必须使用&lt;code&gt;-webkit-min-device-pixel-ratio&lt;/code&gt;媒介查询。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;SVG&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;对于高分辨率屏幕上的显示问题，以及图片在不同尺寸屏幕上显示时的可伸缩问题，可以将可伸缩矢量图形（SVG）作为一个解决方案。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;其他&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;视频与广告也是人们关心的重点。对于视频来说，使用固定比例的方法可以让你根据屏幕尺寸适当地缩放视频。与往常一样，要有意识地关注性能。最好能够为小屏幕用户显示视频链接，而为大屏幕用户直接显示嵌入的视频。对于广告来说，解决技术上的挑战并不困难。如果你是从自己系统中加载广告的，javascript或者一些响应式的html和css都可以为不同分辨率的屏幕上为改变广告提供帮助。更大的问题是如何把销售团队和第三方广告网络也拉上船。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;RESS&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;####两种基本检测方法&#xA;1、用户代理检测&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用户代理检测是通过检测浏览器的用户代理字符串（User Agent）来决定为设备提供哪种站点的方法，这一过程是在服务端完成的。用户代理的名声并不好，在很长一段时间内它都被人们误用或者滥用。那些没有受到青睐的浏览器可以“撒谎”，把它们自己的用户代理字符串修改为那些更受欢迎的浏览器的样子。目前，一淘的仍然使用基于用户代理的检测。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2、功能检测&lt;/p&gt;&#xA;&#xA;&lt;p&gt;很多脚本都有功能检测的功能，其中最为著名的就是Modernizr。它可以测试超过40种不同的功能，而且还能提供另外3样有助于开发的东西：1、一个包含测试结果的javascript对象。2、会在html元素中增加类名，以表明对于功能的支持情况。3、提供一个脚本加载器，可以有条件地加载polyfill。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;刚才说的&lt;code&gt;Modernizr&lt;/code&gt;是在客户端进行检测，还有一个叫&lt;code&gt;modernizr-server&lt;/code&gt;的代码库，可以在服务器端获取&lt;code&gt;Modernizr&lt;/code&gt;检测结果，从而可以在页面被下载之前改变代码结构。使用时需要下载&lt;code&gt;modernizr-server&lt;/code&gt;和最新的javascript库，并将下载好的javascript库命名为&lt;code&gt;modernizr.js&lt;/code&gt;，然后放入&lt;code&gt;modernizr-server/modernizr.js/&lt;/code&gt;文件夹下。原理是：当访问者第一次访问某一页面时会执行javascript的代码库并获取测试的结果。然后这些结果被添加到cookie中，而页面则会立刻重新加载。当下一次加载页面时，代码库会读取cookie中的信息，并且如果可以的话会将其置于会话变量中传回服务器。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;将用户代理检测和功能检测相结合，将服务器端检测和响应式设计相结合，被称为RESS。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;计划、设计流程&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;毫无疑问，响应式设计是一种强大的技术，但它不是银弹。最大化你站点的价值需要花费大量的时间并作出谨慎的决定。你必须将响应式设计整合到项目的计划中去。研究你的分析数据，但是要记住它们也会说谎。仔细考虑一下你的内容，虽然不需要在设计和开发前就把内容最终确定下来，但是你至少应该知道内容的结构。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;响应式设计远远不只是一种简单的策略，它为Web项目带来的是一整套全新的、完整的方法，也是一种新的、可以更好地利用这一平台的工作流程。新流程必须是敏捷而灵活的。要去拥抱Web的交互本性，并开始在浏览器中创建模型。平面图片只能描绘出站点有限的一部分，它们没有能力描绘出用户与网站交互时设计看起来会是什么样子，而且还使得交付变得复杂。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>译:此像素非彼像素</title>
      <link>http://luckydrq.com/tranlation/%E8%AF%91-%E6%AD%A4%E5%83%8F%E7%B4%A0%E9%9D%9E%E5%BD%BC%E5%83%8F%E7%B4%A0/</link>
      <pubDate>2013-09-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;译者：这是篇关于&lt;code&gt;css像素&lt;/code&gt;和&lt;code&gt;设备像素&lt;/code&gt;的老文章，但我最近才有幸拜读，不得不感叹下自己学艺不精。之前做响应式设计，也没有搞清楚两者之间的关系，直到看了&lt;a href=&#34;http://www.quirksmode.org/blog/archives/2010/04/a_pixel_is_not.html&#34; title=&#34;原文地址&#34; target=&#34;_blank&#34;&gt;这篇文章&lt;/a&gt;才逐步理清头绪，现在翻译出来做为学习笔记。如果有翻译得不对的地方或者某处翻译你觉得不爽有更好的建议，请给我留言。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;此像素非彼像素&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;昨天John Gruber在他的文章中提到即将发布的新一代iphone升级了分辨率（达到960x640，而现有的只有480x320），并表达了对此次升级的疑惑。同时，他还想知道这会对web开发者们造成怎样的影响。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;目前，我正在深入研究“移动电话宽度与高度的跨浏览器表现”，并且有充分理由得出这样的结论，99%的情况下这不会对web开发者造成任何影响。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;剩下的1%是非常棘手的，但我希望apple能够通过插入一个像素中间层来解决这个问题。(John指出这样的中间层在Android设备上已经存在了。)&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在我们开始（讨论）之前，先说明一下：我基本上忽略了设备屏幕尺寸，因为它们对web开发者来说是不重要的。而且，我也不想讨论显示细节、像素密度以及其他一些复杂概念。因此，可能我在措辞中使用了错误的术语，在这里提前说声抱歉。&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Web开发者需要什么？&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;当然，我知道web开发者对什么感兴趣。他们需要：css像素，也就是css里声明的像素，比如&lt;code&gt;width:300px&lt;/code&gt;或者&lt;code&gt;font-size:14px&lt;/code&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这些像素与设备的像素密度无关，甚至与传说中即将来临的中间层也是无关的。它们本质上是专门为我们web开发者创造的抽象概念。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个是很容易解释的，我们来考虑一下缩放操作。如果一个用户（把页面）放大了，对于一个设定为&lt;code&gt;width:300px&lt;/code&gt;的元素，会在屏幕上占据越来越大的空间。如果用设备（物理）像素来测量，这个值是越来越大的。但是，在&lt;code&gt;css像素&lt;/code&gt;里，&lt;code&gt;width&lt;/code&gt;仍然是300px，这是通过扩展css像素的宽度来达到放大的效果。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;当缩放因子为100%时，1个&lt;code&gt;css像素&lt;/code&gt;的大小与1个&lt;code&gt;设备像素&lt;/code&gt;的大小是相等的（尽管设备的实际像素会被未来的中间层提供的像素所取代）。如下图所示：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/csspixels_100.gif&#34; /&gt;&#xA;这可能看不出什么，因为1个css像素精确地覆盖了1个设备像素。（可能我应该提醒你“缩放100%”在web开发中是没有意义的，缩放等级对我们来说不重要，真正重要的是我们需要知道当前的屏幕能显示多少css像素。）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;下面的两张图片解释了当用户进行缩放时发生了什么。第一张展示了当用户缩小（页面）时，设备像素（深蓝色背景的格子）与css像素（半透明前背景的格子）的情形。css像素变得更小了，1个设备像素可以覆盖多个css像素。第二张图展示了当用户放大（页面）时，设备像素与css像素的情形。现在1个css像素可以覆盖多个设备像素了。&#xA;&lt;div class=&#34;inline-container&#34;&gt;&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/csspixels_out.gif&#34; /&gt;&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/csspixels_in.gif&#34; /&gt;&#xA;&lt;/div&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这样我们的&lt;code&gt;width:300px&lt;/code&gt;的元素，宽度永远是300个css像素，而这相当于多少个设备像素就取决于当前的缩放因子了。（在iphone上，你可以通过&lt;code&gt;screen.width&lt;/code&gt;除以&lt;code&gt;window.innerWidth&lt;/code&gt;计算得出缩放因子。这个对于浏览器是普遍不兼容的，除非在不久的将来有一份全面而完备的报告。此外，作为一个web开发者，你不会对影响因子感兴趣，而是屏幕能够显示多少css像素。）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这个机制不会变，如果变了，那么所有针对iphone做优化的那些站点，都会瞬间变得非常的不友好，而这是apple不惜一切代价要避免的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，对于一个被全面缩小的网站，它将仍然显示在980 css像素宽度的屏幕里，而这相当于多少设备像素对我们来说就不重要了。（译：如果没有设置intial-scale=1，iphone会对网页进行缩放以至于能够在屏幕里显示整个网页。）&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;两种策略&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;然而，可以有两种策略：&lt;code&gt;device-width&lt;/code&gt;媒介查询和&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; width=&amp;quot;device-width&amp;quot;&amp;gt;&lt;/code&gt;标签(Note：经过译者测试，width写法有所改动，应放在&lt;code&gt;content&lt;/code&gt;属性里定义，如：&lt;code&gt;content=&amp;quot;width=device-width&amp;quot;&lt;/code&gt;)。两种都采用的是设备像素，而非css像素，因为它们报告的是网页的上下文（载体），而不是内在的css属性。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;媒介查询&lt;/h4&gt;&#xA;&#xA;&lt;pre&gt;&lt;code class=&#34;device-width```媒介查询是以设备像素为度量单位来测量设备的宽度。而```width```媒介查询则是以css像素为度量单位测量整个页面的宽度，在iphone上它至少是980px，原因我将在后面解释。&#34;&gt;&amp;lt;img src=&amp;quot;/assets/media/images/2013_09_06/mobile_mediaqueries.jpg&amp;quot; /&amp;gt;&#xA;&#xA;`device-width`是像这样工作的：&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;div.sidebar {&#xA;  width: 300px;&#xA;}&lt;/p&gt;&#xA;&#xA;&lt;p&gt;@media all and (max-device-width: 320px) {&#xA;  //当设备屏幕的宽度小于320px时，该样式就生效了。&#xA;  div.sidebar {&#xA;    width: 100px;&#xA;  }&#xA;}&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;现在sidebar的宽度是300个css像素单位，当设备的宽度是320px或更小时，它（sidebar）的宽度就会变成100个css像素单位。（能跟得上吗？这的确有些复杂）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;顺便说一下，理论上你可以以厘米或者英寸为单位做媒介查询（&lt;code&gt;@media all and (max-device-width: 9cm)&lt;/code&gt;）。不幸的是，它看起来并没有被很好地支持，甚至是iphone。这里的问题是，像英寸这样的物理单位经常会被转换成（css）像素。至今我测试过的所有浏览器上，&lt;code&gt;width: 1in&lt;/code&gt;等同于96像素（这实在是太少了）。所以，这些（以英寸等为单位的）媒介查询是不可靠的。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;&lt;code&gt;meta&lt;/code&gt;标签&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;一般来说，&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; width=&amp;quot;device-width&amp;quot;&amp;gt;&lt;/code&gt;甚至更有用。这个标签，最初是由apple创造的，但同时也被许多移动浏览器支持，实际上是用布局视口（layout viewport）来精确地适配设备屏幕。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;那么，什么是布局视口呢？它是一个区域（css像素），是浏览器通过计算那些宽度被设置成百分比的元素的尺寸而得出的，比如&lt;code&gt;div.sidebar {width: 20%}&lt;/code&gt;。它通常比设备屏幕的宽度要大得多：iphone上是980px，Opera上是850px，Android上是800px，等等。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/mobile_layoutviewport.jpg&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你加上&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; width=&amp;quot;device-width&amp;quot;&amp;gt;&lt;/code&gt;，布局视口的宽度就被限制为设备宽度（设备像素）。在iphone上，这个值是320px。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果你的页面足够窄，窄到当前的屏幕能够显示下，那问题就比较要紧了。去掉页面上任何的css声明以及meta标签。可以发现，它横跨了整个布局视口的可用宽度。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/mq_none.jpg&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这恐怕不是你想要的。你想要文本在屏幕上合适地展现。这就是&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; width=&amp;quot;device-width&amp;quot;&amp;gt;&lt;/code&gt;的任务。当你（在页面上）添加它，整个布局视口就会被限制（iphone上是320px），并且文本也可以合适地展示了。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_06/mq_yes.jpg&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Apple的改变&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;现在，apple的分辨率变化会给&lt;code&gt;device-width&lt;/code&gt;媒介查询和&lt;code&gt;meta&lt;/code&gt;标签带来怎样的影响呢？当然我不能肯定，但我希望对于web开发者来说没有任何变化。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;meta标签&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;meta&lt;/code&gt;标签是最容易解释的。apple刻意发明了它，为的是让页面内容能够很好地显示在iphone上，并且和广大开发者们一起推动它的发展。这意味着，要改变从&lt;code&gt;meta&lt;/code&gt;标签读取的设备宽度的大小，是十分困难的并且代价也是承受不起的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;事实上，Nexus One已经为apple开辟了一条可以遵循的先河。它的官方设备尺寸是480px（竖屏模式下）。但是，当你应用了&lt;code&gt;meta&lt;/code&gt;标签后，它的屏幕尺寸似乎就变成了320px，官方尺寸的2/3。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果我的理解没有错，这就是John Gruber在谈论Nexus的显示时所说的“丢弃了亚像素(sub-pixel)”，从而导致总共减少了1/3的像素。这使得Nexus精确地适配了&lt;code&gt;meta&lt;/code&gt;标签（Note: 480 * &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;3&lt;/sub&gt; = 320）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，基本上，Google已经插入了一个叫做&lt;code&gt;dips&lt;/code&gt;的中间层，从而做到了设备尺寸独立。它介于web开发者使用的css像素宽度与官方设备尺寸之间。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我希望新一代iphone能够应用Nexus的这种技术，即当应用&lt;code&gt;meta&lt;/code&gt;标签查询设备尺寸时报告的是320px（也就是正式分辨率的一半），它之所以是一半而不是2/3，是因为新一代iphone的像素密度要高于Nexus(或其他的一些原因)。&lt;/p&gt;&#xA;&#xA;&lt;h4&gt;媒介查询&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;现在，&lt;code&gt;device-width&lt;/code&gt;媒介查询成了唯一的问题。在Nexus上，它（仍然）以480px作为设备尺寸，尽管事实上（前面已经提到），320px是更合适的结果。我们将看看apple会如何处理。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最根本的问题是dips是否也会被用作媒介查询。总体来说，我想说我们很希望这样。正式的设备尺寸对web开发者来说不重要：我们想知道有多少内容能显示在屏幕上，而且目前看来dips是最合适的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不幸的是，Nexus目前也没有实现（dips用于媒介查询），就媒介查询来说，&lt;code&gt;device-width&lt;/code&gt;仍然是480px而不是320px。但是，也许apple能够为广大web开发者解决这个问题。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;因此，对于普通站点以及那些应用meta标签的站点而言，解决方案已经非常明了了。而对于那些需要用到媒介查询的站点，似乎还不够明了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;敬请关注吧。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>自己动手清洗节气门</title>
      <link>http://luckydrq.com/life/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E6%B8%85%E6%B4%97%E8%8A%82%E6%B0%94%E9%97%A8/</link>
      <pubDate>2013-09-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;之前在&lt;a href=&#34;http://www.autohome.com.cn&#34; target=&#34;_blank&#34;&gt;汽车之家&lt;/a&gt;上看了一篇关于清洗节气门的&lt;a href=&#34;http://www.autohome.com.cn/use/201307/571332.html&#34; target=&#34;_blank&#34;&gt;文章&lt;/a&gt;。感觉也挺简单的，于是周末自己也清洗了一把。废话不多说，直接上图：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;淘宝上搜“节气门清洗剂”，有很多产品，价格在10来块到几十块不等。我用的这瓶3M的只要10来块，效果还行吧，没用过好的。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/17.jpg&#34; /&gt;&#xA;工具箱一个，修车必备：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/15.jpg&#34; /&gt;&#xA;开了近3W5公里，发动机舱已经很脏了，接下来会搞一次发动机舱清洗。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/1.jpg&#34; /&gt;&#xA;这是我们今天动手术的主要部位：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/3.jpg&#34; /&gt;&#xA;看到了吧，连接进气软管的铝制件就是节气门：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/4.jpg&#34; /&gt;&#xA;先拆除进气软管才能看到节气门。进气软管由铝圈套住，先把它解下来：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/5.jpg&#34; /&gt;&#xA;就是这个：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/6.jpg&#34; /&gt;&#xA;拆除软管后，节气门就看到了：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/7.jpg&#34; /&gt;&#xA;节气门的正面是比较干净的，反面就全是积碳了。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/8.jpg&#34; /&gt;&#xA;这时把给车通上电（注意：只是通电不要着车），踩下油门踏板，节气门中间的金属片就会张开角度，ECU就是根据油门深度来判断节气门的开合角度，从而精确控制喷油量的（现在绝大多数车都是电子油门，拉线油门是纯机械控制的）。可以看到里面黑乎乎的很脏：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/9.jpg&#34; /&gt;&#xA;由于科鲁兹的节气门与诸多管线相连，整个拆除比较麻烦，因此我选择直接用布擦洗（效果还是不错的）。把清洗剂喷在抹布上，用手掰开节气门中央的金属片进行擦洗：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/10.jpg&#34; /&gt;&#xA;经过反复清洗，周边的一些黑东东似乎擦不掉。。。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/12.jpg&#34; /&gt;&#xA;最后，按照原先的拆除步骤，反过来操作复原。&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/14.jpg&#34; /&gt;&#xA;收工了，身上各种脏啊：&#xA;&lt;img src=&#34;/assets/media/images/2013_09_01/16.jpg&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;总结一下，整个操作的过程中还是比较顺利的。有几点需要注意下：1、整个操作过程中需要带手套，以免粘上清洗剂（强腐蚀性）。2、在清洗节气门的时候，不要直接将清洗剂喷入节气门，那样会流到气缸里，损伤发动机。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这次清洗并没有拆除整个节气门（对其他管路暂时还不熟，以后再介绍整个拆除的工序），担心效果不明显，不过晚上着车后发现怠速转速下降了，低扭说不上明显好转但能感觉到起步更轻盈了。清理积碳使得整个进气更加顺畅了，洗洗更健康啊。&lt;/p&gt;&#xA;</description>
    </item>
    <item>
      <title>git hook在项目里的简单应用</title>
      <link>http://luckydrq.com/tools/git-hook%E5%9C%A8%E9%A1%B9%E7%9B%AE%E9%87%8C%E7%9A%84%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8/</link>
      <pubDate>2013-08-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;上一篇关于&lt;code&gt;git&lt;/code&gt;的博文扯到了&lt;code&gt;git hook&lt;/code&gt;，一直想用它搞点实用的事情出来，正好最近的项目处于预发布之前的最后测试阶段，页面上的css文件地址换成了cdn地址，这样带来的麻烦就是如果css要修改，必须要重新发布到cdn上。为了偷懒，就想每次git commit成功后执行hook脚本自动完成发布cdn的事情。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;关于&lt;code&gt;git hook&lt;/code&gt;，网上有一大堆介绍，可以看看&lt;a href=&#34;http://blog.jobbole.com/26131/&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;。总得说来，&lt;code&gt;git hook&lt;/code&gt;可以分为客户端&lt;code&gt;hook&lt;/code&gt;和服务器端&lt;code&gt;hook&lt;/code&gt;。客户端&lt;code&gt;hook&lt;/code&gt;用于客户端的操作，如提交和合并。服务器端&lt;code&gt;hook&lt;/code&gt;用于git服务器端的操作，如接收被推送的提交。在&lt;code&gt;git&lt;/code&gt;操作周期的不同阶段，会触发相应的&lt;code&gt;hook&lt;/code&gt;（如果你写了）。所有的这些脚本，都存放在你的工程的&lt;code&gt;Git&lt;/code&gt;目录下，具体路径为&lt;code&gt;.git/hooks/&lt;/code&gt;。执行&lt;code&gt;ls .git/hooks&lt;/code&gt;查看一下，会发现有很多以&lt;code&gt;.sample&lt;/code&gt;结尾的文件，再看看这些文件内容，全都是shell脚本。这些文件是&lt;code&gt;git&lt;/code&gt;为你预置的一些&lt;code&gt;hook&lt;/code&gt;脚本，只要把文件的后缀名&lt;code&gt;.sample&lt;/code&gt;去掉，脚本就生效了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里面的大多数&lt;code&gt;hook&lt;/code&gt;我都没有用过，就只说说项目里的用法。经过尝试，最终选用了&lt;code&gt;commit-msg&lt;/code&gt;和&lt;code&gt;post-commit&lt;/code&gt;这两个客户端&lt;code&gt;hook&lt;/code&gt;。这里可能有人要问，不就是发个cdn么，这么屁大点事还要用两个脚本？对于这里的逻辑，我认为是这样的：1、只有当本次提交涉及修改的文件里包括我想要的css文件时，才能发布cdn。2、只有当提交操作完成（即commit成功），再做发布cdn的操作。经过试验发现，在提交操作完成后，找不到合适的办法获取本次提交的修改文件列表，这样就无法知道本次提交是否涉及css文件。这里可能又有人会说，干脆么每次提交都整一次发布好了哇。可以是可以，但是有点不爽啊。。。&lt;code&gt;commit-msg&lt;/code&gt;是在提交之前调用的，如果脚本返回非零的值，那么本次提交将会被取消。&lt;code&gt;post-commit&lt;/code&gt;是在提交之后调用的，如果提交不成功，那么它就不会执行。对于检测是否存在目标的css文件，我用了比较土的办法，在&lt;code&gt;commit-msg&lt;/code&gt;脚本里，检查修改文件里是否存在目标文件，如果存在，就创建一个空文件A。提交完成后，在&lt;code&gt;post-commit&lt;/code&gt;里检查空文件A是否存在，如果存在，就执行发布cdn操作。下面就把代码贴出来：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;commit-msg&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/sh&#xA;files=`git diff --cached --name-only`&#xA;EXTRA_File=&amp;quot;$EXTRA$&amp;quot;&#xA;&#xA;if [ -f $EXTRA_File ]; then&#xA;  rm $EXTRA_File&#xA;fi&#xA;&#xA;for file in $files; do&#xA;  #echo $file&#xA;&#xA;  if [ &amp;quot;$file&amp;quot; == &amp;quot;public/index.css&amp;quot; ]; then&#xA;    touch $EXTRA_File&#xA;    break&#xA;  fi&#xA;done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;post-commit&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/sh&#xA;EXTRA_File=&amp;quot;$EXTRA$&amp;quot;&#xA;&#xA;if [ -f $EXTRA_File ]; then&#xA;  cd ~/workspace/mosaic-demo/public/mm&#xA;  sh deploy.sh&#xA;  rm $EXTRA_File&#xA;fi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;deploy.sh&lt;/code&gt;封装了css压缩、上传cdn的操作，也就是你想要做的操作，也贴出来走完整个流程。不过主要就是上面的两段脚本，很简单吧！如果有朋友有更好的办法，欢迎拍砖！！！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;deploy.sh&lt;/code&gt;:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;#!/bin/sh&#xA;cp ../index.css ./build/index.css&#xA;cd ../../&#xA;grunt&#xA;cd public/mm&#xA;echo &#39;uploading css to cdn...&#39;&#xA;node deploy.js&#xA;echo &#39;uploading success!&#39;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
    </item>
    <item>
      <title>创建基于本地协议的git服务器</title>
      <link>http://luckydrq.com/tools/%E5%88%9B%E5%BB%BA%E5%9F%BA%E4%BA%8E%E6%9C%AC%E5%9C%B0%E5%8D%8F%E8%AE%AE%E7%9A%84git%E6%9C%8D%E5%8A%A1%E5%99%A8/</link>
      <pubDate>2013-07-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天了解了下git挂钩（&lt;code&gt;git hook&lt;/code&gt;），本想通过&lt;code&gt;Github&lt;/code&gt;实践一下其中的服务器挂钩。后来经过Google发现，&lt;code&gt;Github&lt;/code&gt;只提供所谓的&lt;code&gt;web hook&lt;/code&gt;，即当你push代码至某个repository时，&lt;code&gt;Github&lt;/code&gt;服务器会发一个POST请求到你所注册的url，本次push的相关信息会作为一个JSON串随请求一起发过去。这与我的需求不符，我想要git服务器在收到push通知后执行一些操作（本地操作或者网络操作）。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;于是，就想自己搭个git代码服务器。架设git服务器共有4种协议：本地协议、SSH协议、git协议、HTTP/S协议。今天就说说最简单的一种：本地协议。通俗地说，git服务器就是一个代码远程仓库。先来看下书上的一段文字：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;远程仓库通常只是一个裸仓库（bare repository）—— 即一个没有当前工作目录的仓库。因为该仓库只是一个合作媒介，所以不需要从硬盘上取出最新版本的快照；仓库里存放的仅仅是 Git 的数据。简单地说，裸仓库就是你工作目录中.git 子目录内的内容。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;以上文字的意思就是，仓库必须是裸的。我们先从创建裸仓库开始：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd ~&#xA;git init --bare gitLocal    //仓库目录：~/gitLocal&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;然后，我们创建并初始化一个代码目录，比如Test.git&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd gitLocal&#xA;git init --bare Test.git    &#xA;&#xA;//注意，这里我踩过坑，如果不加--bare参数，后续在push时会发生[remote rejected]错误&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;代码目录创建好后，我们就可以对远程仓库进行拉取和推送数据了。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;cd ~&#xA;git clone ~/gitLocal/Test.git    //是不是和Github的git地址很像？&#xA;cd Test&#xA;touch 1.js&#xA;git add 1.js&#xA;git commit -m &#39;add a file&#39;&#xA;git push origin master&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这样就完成了一次提交。后面的工作就和操作&lt;code&gt;Github&lt;/code&gt;的远程仓库没区别了。&lt;/p&gt;&#xA;</description>
    </item>
  </channel>
</rss>